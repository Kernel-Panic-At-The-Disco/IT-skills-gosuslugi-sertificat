# Алгоритмы и структуры данных

## Вопрос 1  
Какой алгоритм использует стратегию "жадного выбора" и строит основное дерево, добавляя минимальные ребра, пока не соединит все вершины?  

- Алгоритм Прима  
- Алгоритм Флойда-Уоршелла  
- Алгоритм Дейкстры  
- Алгоритм Беллиана-Форда  
- Алгоритм Форда-Фалкерсона  

---

## Вопрос 2  
В каком из приведенных случаев сортировка вставками продемонстрирует наибольшую эффективность?  

- Список, который нужно разбить на равные блоки и обрабатывать каждый блок независимо  
- Список чисел, где множество элементов равны нулю и необходимо использовать подсчет по значениям  
- Набор с уникальными значениями, требующий управления минимальными/максимальными элементами  
- Массив, практически упорядоченный по возрастанию, где лишь несколько элементов оказались не на месте  
- Массив, состоящий из случайных строк одинаковой длины, где требуется сравнение символов  

---

## Вопрос 3  
Какая характеристика верно отражает суть алгоритма бинарного дерева поиска (BST)?  

- Удаление узла в бинарном дереве поиска всегда требует полной перестройки всех элементов дерева  
- Каждый узел в бинарном дереве хранит не больше двух потомков, левое поддерево меньше, правое больше  
- Бинарное дерево поиска быстрее любых других деревьев при работе с хаотично распределенными значениями  
- Любое бинарное дерево автоматически поддерживает сбалансированность, обеспечивая моментальный поиск  
- Бинарное дерево поиска работает только с отсортированными элементами и выполняет поиск всегда за \( O(\log n) \)  

---

## Вопрос 4  
Какой алгоритм поиска позволит использовать меньшее количество итераций, если данные в массиве не отсортированы и массив имеет относительно небольшой размер?  

- Линейный поиск  
- Поиск прыжками  
- Бинарный поиск  
- Интерполяционный поиск  
- Поиск Фибоначчи  

---

## Вопрос 5  
Какой из перечисленных типов данных НЕ подходит для быстрого поиска элементов по ключу?  

- Сбалансированное дерево  
- Хеш-таблица  
- Связанный список  
- Динамический массив  
- Одномерный массив  

---

## Вопрос 6  
Почему при работе с пользовательским вводом или данными из файла обычно используют динамические массивы, а не статические?  

- Так как они снижают количество копирований данных при вставках  
- Чтобы заранее указать максимально возможный размер данных  
- Так как их размер может расти по мере поступления новых данных  
- Потому что они используют меньше оперативной памяти в любом случае  
- Чтобы обеспечить быстрый доступ к первому элементу  

---

## Вопрос 7  
Какая структура данных удобна для управления потоком задач, если между ними существуют зависимости, и некоторые задачи могут выполняться только после завершения других?  

- Очередь  
- Массив  
- Граф  
- Стек  
- Хеш-таблица  

---

## Вопрос 8  
Какой из вариантов лучше всего описывает применение очереди?  

- Управление вызовами функций  
- Управление задачами в принтере  
- Алгоритмы обхода деревьев  
- Хранение промежуточных данных в кэше  
- Реализация отката действий  

---

## Вопрос 9  
Ваша команда пытается ускорить алгоритм, имеющий временную сложность \( O(n^2) \). Предполагается, что при правильном подходе удастся достичь \( O(n \log n) \). Какое из перечисленных действий НЕ приведет к нужному результату с точки зрения снижения асимптотической сложности? 

- Учитывать дополнительные накладные расходы на память и балансировать глубину рекурсии  
- Произвести более тщательный выбор опорного элемента в рекурсивном алгоритме  
- Применить оптимизированную процедуру слияния или разбиения в сортировочном алгоритме  
- Уменьшить число самих итераций в тестовых прогонах, сохранив исходный алгоритм  
- Заменить структуру данных на ту, которая поддерживает эффективные операции вставки и удаления  

---

## Вопрос 10  
Почему в связном списке доступ по индексу считается менее эффективным, чем в массиве?  

- Связный список использует случайные индексы для каждого узла, не совпадающие с их порядком  
- Для нахождения элемента по индексу приходится последовательно переходить от узла к узлу  
- В связном списке элементы располагаются непрерывно, но требуют частого копирования при доступе  
- Связный список при добавлении всегда перезаписывает все предыдущие указатели полностью  
- В связном списке невозможно удалять элемент, не зная его точного индекса заранее  