# Algorithms_base

## Вопрос 1  
Какой алгоритм использует стратегию "жадного выбора" и строит основное дерево, добавляя минимальные ребра, пока не соединит все вершины?  

- Алгоритм Прима  
- Алгоритм Флойда-Уоршелла  
- Алгоритм Дейкстры  
- Алгоритм Беллиана-Форда  
- Алгоритм Форда-Фалкерсона  

---

## Вопрос 2  
В каком из приведенных случаев сортировка вставками продемонстрирует наибольшую эффективность?  

- Список, который нужно разбить на равные блоки и обрабатывать каждый блок независимо  
- Список чисел, где множество элементов равны нулю и необходимо использовать подсчет по значениям  
- Набор с уникальными значениями, требующий управления минимальными/максимальными элементами  
- Массив, практически упорядоченный по возрастанию, где лишь несколько элементов оказались не на месте  
- Массив, состоящий из случайных строк одинаковой длины, где требуется сравнение символов  

---

## Вопрос 3  
Какая характеристика верно отражает суть алгоритма бинарного дерева поиска (BST)?  

- Удаление узла в бинарном дереве поиска всегда требует полной перестройки всех элементов дерева  
- Каждый узел в бинарном дереве хранит не больше двух потомков, левое поддерево меньше, правое больше  
- Бинарное дерево поиска быстрее любых других деревьев при работе с хаотично распределенными значениями  
- Любое бинарное дерево автоматически поддерживает сбалансированность, обеспечивая моментальный поиск  
- Бинарное дерево поиска работает только с отсортированными элементами и выполняет поиск всегда за \( O(log n) \)  

---

## Вопрос 4  
Какой алгоритм поиска позволит использовать меньшее количество итераций, если данные в массиве не отсортированы и массив имеет относительно небольшой размер?  

- Линейный поиск  
- Поиск прыжками  
- Бинарный поиск  
- Интерполяционный поиск  
- Поиск Фибоначчи  

---

## Вопрос 5  
Какой из перечисленных типов данных НЕ подходит для быстрого поиска элементов по ключу?  

- Сбалансированное дерево  
- Хеш-таблица  
- Связанный список  
- Динамический массив  
- Одномерный массив  

---

## Вопрос 6  
Почему при работе с пользовательским вводом или данными из файла обычно используют динамические массивы, а не статические?  

- Так как они снижают количество копирований данных при вставках  
- Чтобы заранее указать максимально возможный размер данных  
- Так как их размер может расти по мере поступления новых данных  
- Потому что они используют меньше оперативной памяти в любом случае  
- Чтобы обеспечить быстрый доступ к первому элементу  

---

## Вопрос 7  
Какая структура данных удобна для управления потоком задач, если между ними существуют зависимости, и некоторые задачи могут выполняться только после завершения других?  

- Очередь  
- Массив  
- Граф  
- Стек  
- Хеш-таблица  

---

## Вопрос 8  
Какой из вариантов лучше всего описывает применение очереди?  

- Управление вызовами функций  
- Управление задачами в принтере  
- Алгоритмы обхода деревьев  
- Хранение промежуточных данных в кэше  
- Реализация отката действий  

---

## Вопрос 9  
Ваша команда пытается ускорить алгоритм, имеющий временную сложность \( O(n^2) \). Предполагается, что при правильном подходе удастся достичь \( O(n log n) \). Какое из перечисленных действий НЕ приведет к нужному результату с точки зрения снижения асимптотической сложности? 

- Учитывать дополнительные накладные расходы на память и балансировать глубину рекурсии  
- Произвести более тщательный выбор опорного элемента в рекурсивном алгоритме  
- Применить оптимизированную процедуру слияния или разбиения в сортировочном алгоритме  
- Уменьшить число самих итераций в тестовых прогонах, сохранив исходный алгоритм  
- Заменить структуру данных на ту, которая поддерживает эффективные операции вставки и удаления  

---

## Вопрос 10  
Почему в связном списке доступ по индексу считается менее эффективным, чем в массиве?  

- Связный список использует случайные индексы для каждого узла, не совпадающие с их порядком  
- Для нахождения элемента по индексу приходится последовательно переходить от узла к узлу  
- В связном списке элементы располагаются непрерывно, но требуют частого копирования при доступе  
- Связный список при добавлении всегда перезаписывает все предыдущие указатели полностью  
- В связном списке невозможно удалять элемент, не зная его точного индекса заранее  

---

## Вопрос 11  
Сравните быструю сортировку и сортировку слиянием.  
Какое утверждение НЕверно описывает их различия?  

- Сортировка слиянием всегда имеет сложность \( O(n log n) \), в отличие от быстрой сортировки  
- В среднем быстрая сортировка быстрее, но в худшем случае её сложность может быть \( O(n^2) \)  
- Быстрая сортировка использует \( O(log n) \) памяти, а сортировка слиянием требует \( O(n) \)  
- Сортировка слиянием имеет \( O(n) \) сложность в среднем, тогда как быстрая — \( O(n log n) \)  
- Сортировка слиянием требует \( O(n) \) памяти, а быстрая сортировка выполняется "на месте"  

---

## Вопрос 12  
Выберите верное объяснение, почему динамический массив может изменять свой размер и при этом сохранять доступ к элементам за \( O(1) \) в большинстве случаев  

- В таком массиве можно выключать индексацию при переполнении, переходя к поиску в линейном режиме  
- Так как возможно перестраивать массив в двоичное дерево, чтобы распределить элементы по уровням памяти  
- Может создавать массив в связанном виде, чтобы обойтись без индексов и хранить указатели на "следующий элемент"  
- Может использовать стратегию роста при достижении лимита, увеличивая резерв памяти и сохраняя непрерывную область хранения  
- Такой массив может выделять память для каждого нового элемента отдельно, полностью копируя все данные  

---

## Вопрос 13  
К какому типу алгоритмов относится поиск элемента в ассоциативном массиве (Map) по ключу?  

- Поиск с хешированием  
- Динамическое программирование  
- Двоичный поиск  
- Жадный поиск в глубину  
- Жадные алгоритмы  

---

## Вопрос 14  
Какой алгоритм поиска сможет выполнить поиск быстрее в десятки раз, если исходный массив уже отсортирован и нужно сделать множество поисковых операций?  

- Поиск в глубину  
- Поиск Фибоначчи  
- Поиск с хешированием  
- Бинарный поиск  
- Линейный поиск  

---

## Вопрос 15  
Какая структура данных НЕ сможет при каждом вызове функции отменять последнее действие пользователя?  

- Очередь  
- Дек  
- Связанный список  
- Массив  
- Стек  

---

## Вопрос 16  
Выберите верное объяснение, почему поиск по хеш-таблице обеспечивает наиболее быструю скорость поиска и не требует предварительной сортировки данных.  

- Так как он использует хеш-функцию для вычисления позиции элемента в памяти, исключая необходимость последовательного перебора данных  
- Так как он требует, чтобы все данные были отсортированы заранее, иначе не сможет корректно работать  
- Так как он сканирует все элементы по порядку, пока не найдет совпадение  
- Так как он заменяет все отсутствующие элементы массива нулевыми значениями перед поиском  
- Так как он может разделять массив на равные подмассивы и обрабатывать их независимо  

---

## Вопрос 17  
Каково главное преимущество поразрядной сортировки в случае, если сортируются данные, представленные в виде чисел с фиксированной длиной, и требуется стабильная сортировка?  

- Поразрядная сортировка учитывает порядок расположения элементов в памяти, что снижает затраты на перестановки  
- Сортировка выполняется по аналогии с алгоритмом быстрой сортировки, но без рекурсивного разбиения массива  
- Алгоритм использует принцип "разделяй и властвуй", что делает его эффективным для всех типов данных  
- Использование поразрядной сортировки исключает необходимость сравнения элементов, что ускоряет процесс  
- Этот алгоритм работает быстрее за счет оптимального выбора опорного элемента на каждом шаге  

---

## Вопрос 18  
В чем заключается ключевое отличие в управлении памятью между массивом и связным списком?  

- Массив требует пересортировки при каждом добавлении элемента, а связный список — нет  
- Связный список требует преобразовывать все индексы при любой модификации  
- Массив хранится в непрерывном блоке памяти, а элементы связного списка распределены в памяти и связаны указателями  
- Массивы могут самостоятельно изменять свой размер при добавлении элементов  
- В связном списке каждый элемент хранится по соседству с предыдущим  

---

## Вопрос 19  
В высоконагруженной системе для обработки большого массива данных вы заменили устоявшийся алгоритм новым решением, ожидая уменьшить время выполнения. Однако тестирование показало резкий рост потребления памяти и общее замедление работы.  

Что необходимо сделать в этом случае?  

- Проверить поведение алгоритма на наборах данных разного размера, чтобы выявить закономерности роста потребления памяти  
- Использовать динамические массивы вместо фиксированной длины, чтобы повысить адаптивность алгоритма  
- Оценить новые структуры данных, чтобы выявить дополнительные накладные расходы на память  
- Переключить обработку данных в итеративный режим, чтобы уменьшить нагрузку на стек памяти  
- Оптимизировать работу с кэш-памятью и распределением ресурсов, так как узкое место может находиться в механизме хранения данных  

---

## Вопрос 20  
Какой алгоритм сортировки последовательно уменьшает интервал между сравниваемыми элементами и особенно эффективен для почти упорядоченных массивов?  

- Пузырьковая сортировка  
- Быстрая сортировка  
- Сортировка слиянием  
- Сортировка Шелла  
- Пирамидальная сортировка  

---

## Вопрос 21  
В каком ответе указано значимое качество алгоритма сортировки в тех случаях, когда значительная часть элементов уже стоит на своих местах?  

- Сортировка выбором проходит по массиву, выбирая минимальные элементы и упорядочивая их независимо от исходного состояния  
- Сортировка вставками адаптируется к уже отсортированным частям массива и работает за \( O(n) \) в лучшем случае  
- Поразрядная сортировка обрабатывает числа по разрядам, но не учитывает частично отсортированные массивы  
- Сортировка слиянием использует стратегию "разделяй и властвуй" и одинаково эффективна при любом порядке элементов  
- Гномья сортировка переставляет элементы при нарушении порядка, но не использует адаптивные механизмы ускорения  

---

## Вопрос 22  
Какой алгоритм поиска наименее эффективен для выполнения поиска в небольшом неотсортированном массиве, если требуется выполнить поиск всего несколько раз?  

- Бинарный поиск  
- Поиск с хешированием  
- Линейный поиск  
- Интерполяционный поиск  
- Экспоненциальный поиск  

---

## Вопрос 23  
Какая из перечисленных структур данных обеспечивает поведение стека (LIFO) непосредственно и на уровне встроенных операций, без необходимости дополнительной логики или пользовательской реализации?  

- Хеш-таблица  
- Дек  
- Массив  
- Граф  
- Очередь  

---

## Вопрос 24  
Какое свойство стека делает его подходящим для реализации функции "Отменить последнее действие" в текстовом редакторе?  

- Стек обрабатывает элементы по принципу LIFO  
- Стек позволяет работать с обеими концами  
- Стек хранит ссылки на предыдущие состояния  
- Стек обрабатывает элементы в порядке FIFO  
- Стек автоматически отслеживает изменения и сохраняет их в хронологическом порядке  

---

## Вопрос 25  
Почему при вставке элемента в середину связного списка он может оказаться эффективнее статического массива?  

- В статическом массиве добавление элемента происходит только в самый конец  
- Связный список всегда хранится непрерывным блоком в памяти  
- В связном списке находятся те элементы, которые не могут дублироваться  
- В связном списке можно обойтись без изменения индексов остальных элементов  
- Связный список предоставляет мгновенный доступ к элементам по индексу  