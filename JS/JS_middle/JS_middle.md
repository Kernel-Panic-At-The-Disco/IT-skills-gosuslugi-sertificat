# JS_middle

## Вопрос 1

Каким будет результат выполнения следующего кода?

1 const scores = [3, 6, 9];
2 const doubled = scores.map(n => n * 2);
3 console.log(doubled[1] - scores[0]);

- 6
- 3
- 0
- 9
- 12

---

## Вопрос 2

Какое утверждение НЕВЕРНО относительно хранения данных в браузере?

- Данные в sessionStorage удаляются после закрытия вкладки
- Данные в cookies могут быть отправлены на сервер
- localStorage может содержать бинарные файлы напрямую
- sessionStorage работает только в пределах одной вкладки
- localStorage доступен только в том же домене

---

## Вопрос 3

Какое из следующих выражений вернёт true?

- typeof [] === 'array'
- 0 === '0'
- null == undefined
- NaN == NaN
- '5' === 5

---

## Вопрос 4

Каким будет результат выполнения данного кода?

1 let count = 5;
2 count = ++count + 6;
3 console.log(count);

- NaN
- 11
- 12
- 10
- undefined

---

## Вопрос 5

Вы должны запустить некий участок кода как минимум один раз и лишь затем проверить, можно ли продолжать повтор. Какую конструкцию предпочтительнее выбрать?

- do-while
- if-else
- for-of
- for-in
- switch-case

---

## Вопрос 6

Вы объявили функцию, которая возвращает значение, внутри цикла for. Что произойдет с переменной, в которой сохранена эта функция?

- Функция превращается в метод массива
- Любая функция внутри цикла становится глобальной
- Переменная будет доступна только до окончания итерации
- Переменная имеет блочную область видимости в пределах for
- Возвращаемое значение стирается по завершении цикла

---

## Вопрос 7

Необходимо объединить два массива объектов arrA и arrB в один массив, добавив элементы второго к первому. Какой способ это сделает?

1 const arrA = [{ id: 1 }, { id: 2 }];
2 const arrB = [{ id: 3 }, { id: 4 }];
3 function mergeArrays(a, b) {
4   return ___
5 }
6 console.log(mergeArrays(arrA, arrB));

- a.concat(b).reduce((acc, el) => acc + el, [])
- a.map(item => b.push(item))
- b.forEach(el => a[el] = el)
- [...a, ...b]
- Object.assign(a, b)

---

## Вопрос 8

Вам нужно реализовать систему локализации интерфейса. Для каждой строки интерфейса должно быть несколько переводов на разные языки. Необходимые функциональности:

* Хранение переводов на русском, английском и других языках
* Быстрое получение перевода по ключу и языку
* Возможность обновлять и добавлять новые переводы

Какой способ организации данных наиболее подходит для хранения текстов локализации?

- Хранить всё в одной огромной JSON-строке и регулярно её парсить
- Делать глобальную переменную для каждого языка и записывать переводы в виде: en_key: translation
- Создать объект, где ключи это языки, а значение объект с ключами-строками и значениями - переводами
- Использовать массив, где каждый элемент это пара «ключ-строка, перевод»
- Сформировать общий массив всех переводов и искать в нём по индексу

---

## Вопрос 9

Какую концепцию наследования в JavaScript демонстрирует код ниже?

1 function A() {}
2 A.prototype.shared = 'value';
3 function B() {}
4 B.prototype = Object.create(A.prototype);
5 B.prototype.unique = 'another';
6 const b = new B();

- Поверхностное наследование
- Цепочка прототипов вручную
- Инкапсуляция на уровне объекта
- Формальное клонирование
- Наследование свойств

---

## Вопрос 10

Что происходит, когда у объекта в JavaScript запрашивается свойство, которого у него нет?

- Происходит возврат к значению по умолчанию из конструктора
- JavaScript создает это свойство автоматически
- Объект возвращает undefined, если свойства нет
- Объект возвращает null, если свойства нет
- Вызывается исключение

---

## Вопрос 11

Что произойдет при выполнении кода?

1 function createCounter() {
2   let count = 0;
3   return {
4     increment() {
5       count++;
6       return count;
7     }
8   };
9 }
10 const counter = createCounter();
11 console.log(counter.increment());

- Создается глобальная переменная count и метод increment у counter, который увеличивает count
- Метод increment использует замыкание для доступа к count и увеличивает его
- Каждый вызов increment возвращает 1, так как заново создается count и увеличивается на 1
- count становится недоступным после первой итерации
- Функция createCounter ничего не возвращает

---

## Вопрос 12

Что возвращает вызов fetch()?

- Результат сетевого запроса в виде объекта JSON, доступного без дополнительных вызовов
- Функцию, возвращающую результат сетевого вызова при вызове с параметрами запроса
- Объект, позволяющий отследить статус операции и обработать её результат после завершения
- Синхронную структуру, описывающую заголовки и тело HTTP-ответа сервера запроса
- Статический объект, отражающий параметры и конфигурацию сетевого соединения клиента

---

## Вопрос 13
Каким будет результат выполнения следующего кода?
```
const list = [8];
list[1] = list[0] * 2;
console.log(list.length)
```
- 10
- 2
- 20
- 3
- 1

---

## Вопрос 14
Какое из следующих выражений даст значение false?

- 5 + 2 > 3
- true == false
- 4 === '4'
- 'a' < 'z'
- 10 > 2

---

## Вопрос 15
Каким будет результат выполнения данного кода?
```
let str = "Hello" || 0 && "JS";
console.log(str);
```
- undefined
- 0
- 5
- "JS"
- "Hello"

---

## Вопрос 16
Каково основное правило, описывающее доступ к параметрам внутри функции в JavaScript?

- Они сохраняются в глобальном объекте
- Они доступны во всем приложении
- Они скрыты от замыканий
- Они локальны внутри функции
- Они передаются в объекты при помощи this

---

## Вопрос 17
Вы хотите создать новый массив, исключив из исходного массива все элементы, у которых amount меньше 3. Какой метод и условие нужно использовать?
1 const inventory = [
2   { name: 'Apples', amount: 5 },
3   { name: 'Bananas', amount: 2 },
4   { name: 'Oranges', amount: 7 },
5   { name: 'Grapes', amount: 1 }
6 ];
7 function filterItems(items) {
8   return ___
9 }
10 console.log(filterItems(inventory));

- items.filter(item => item.amount >= 3)
- items.reduce((acc, item) => item.amount < 3, [])
- items.forEach(item => item.amount < 3)
- items.map(item => item.amount > 3)
- items.slice(item => item.amount > 3)

---

## Вопрос 18
Вы разрабатываете внутреннюю CRM систему для крупной компании. Ваша задача - создать модуль, хранения информации о сотрудниках для последующей аналитики и отчетов.
Необходимые функциональности:
- Создание хранилища, где фиксируются ФИО, телефон, отдел, должность, дата приема на работу
- Возможность добавления новых сотрудников и обновления их информации
- Фильтрация сотрудников по отделам и должности, подсчет общего количества
Проанализируйте техническое задание: Как вы организуете структуру данных для хранения информации о сотрудниках?

- Использовать массив объектов, где каждый сотрудник - один объект (ФИО, телефон, отдел, должность, дата)
- Сохранить всю информацию в одной строке через разделитель и каждый раз парсить её
- Создать отдельный объект только для дат приема, а все остальное вынести в глобальную переменную
- Превратить каждую строку (ФИО, телефон, отдел, должность, дата) в один общий массив
- Сделать объект, где каждое поле - это массив со всеми ФИО, всеми телефонами и т.д

---

## Вопрос 19
Какую концепцию наследования в JavaScript демонстрирует код ниже?

1 const controls = {
2   interact() {
3     return "Interacting"
4   }
5 }
6 const button = Object.create(controls)
7 console.log(button.interact())

- Делегирование через прототип
- Переопределение прототипа
- Наследование через mixin
- Прямое клонирование объекта
- Наследование через замыкание

---

## Вопрос 20
Чем отличается прототипное наследование от классического наследования?

- Прототипное наследование не может быть переопределено
- Прототипное наследование использует абстрактные классы для наследования
- Прототипное наследование требует создания экземпляров через new
- Прототипное наследование основано на делегировании через ссылки между объектами
- Прототипное наследование работает только с примитивами

---

## Вопрос 21
Чем объясняется поведение этого кода?

1 function outer() {
2   let count = 0;
3   return function() {
4     count++;
5     return count;
6   };
7 }
8 const counter = outer();
9 console.log(counter());
10 console.log(counter());

- Функция не сохраняет состояние между вызовами
- Функция возвращает 0, так как count обнуляется каждый раз
- Функция возвращает значение 1 при каждом вызове
- Функция возвращает увеличивающееся значение, используя замыкание
- Функция выходит undefined, так как count не определён

---

## Вопрос 22
Когда уместно использовать setTimeout?

- Когда структура кода предполагает множественные циклы с предсказуемым временем выполнения
- Когда вызываемая функция формирует результат на основе внешнего флага
- Когда необходимо искусственно сместить выполнение функции по времени в пределах основной очереди
- Когда логика построена вокруг итеративных преобразований массивов
- Когда требуется отреагировать на пользовательское событие и сохранить данные