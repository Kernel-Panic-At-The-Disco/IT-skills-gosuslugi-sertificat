# **JS\_middle**

**Вопрос 1**

Каким будет результат выполнения следующего кода?

1 const scores \= \[3, 6, 9\];  
2 const doubled \= scores.map(n \=\> n \* 2);  
3 console.log(doubled\[1\] \- scores\[0\]);

1. 6  
2. 3  
3. 0  
4. 9  
5. 12

**Вопрос 2**

Какое утверждение НЕВЕРНО относительно хранения данных в браузере?

1. Данные в sessionStorage удаляются после закрытия вкладки  
2. Данные в cookies могут быть отправлены на сервер  
3. localStorage может содержать бинарные файлы напрямую  
4. sessionStorage работает только в пределах одной вкладки  
5. localStorage доступен только в том же домене

**Вопрос 3**

Какое из следующих выражений вернёт true?

1. typeof \[\] \=== 'array'  
2. 0 \=== '0'  
3. null \== undefined  
4. NaN \== NaN  
5. '5' \=== 5

**Вопрос 4**

Каким будет результат выполнения данного кода?

1 let count \= 5;  
2 count \= \++count \+ 6;  
3 console.log(count);

1. NaN  
2. 11  
3. 12  
4. 10  
5. undefined

**Вопрос 5**

Вы должны запустить некий участок кода как минимум один раз и лишь затем проверить, можно ли продолжать повтор. Какую конструкцию предпочтительнее выбрать?

1. do-while  
2. if-else  
3. for-of  
4. for-in  
5. switch-case

**Вопрос 6**

Вы объявили функцию, которая возвращает значение, внутри цикла for. Что произойдет с переменной, в которой сохранена эта функция?

1. Функция превращается в метод массива  
2. Любая функция внутри цикла становится глобальной  
3. Переменная будет доступна только до окончания итерации  
4. Переменная имеет блочную область видимости в пределах for  
5. Возвращаемое значение стирается по завершении цикла

**Вопрос 7**

Необходимо объединить два массива объектов arrA и arrB в один массив, добавив элементы второго к первому. Какой способ это сделает?

1 const arrA \= \[{ id: 1 }, { id: 2 }\];  
2 const arrB \= \[{ id: 3 }, { id: 4 }\];  
3 function mergeArrays(a, b) {  
4   return \_\_\_  
5 }  
6 console.log(mergeArrays(arrA, arrB));

1. a.concat(b).reduce((acc, el) \=\> acc \+ el, \[\])  
2. a.map(item \=\> b.push(item))  
3. b.forEach(el \=\> a\[el\] \= el)  
4. \[...a, ...b\]  
5. Object.assign(a, b)

**Вопрос 8**

Вам нужно реализовать систему локализации интерфейса. Для каждой строки интерфейса должно быть несколько переводов на разные языки. Необходимые функциональности:

* Хранение переводов на русском, английском и других языках  
* Быстрое получение перевода по ключу и языку  
* Возможность обновлять и добавлять новые переводы

Какой способ организации данных наиболее подходит для хранения текстов локализации?

1. Хранить всё в одной огромной JSON-строке и регулярно её парсить  
2. Делать глобальную переменную для каждого языка и записывать переводы в виде: en\_key: translation  
3. Создать объект, где ключи это языки, а значение объект с ключами-строками и значениями \- переводами  
4. Использовать массив, где каждый элемент это пара «ключ-строка, перевод»  
5. Сформировать общий массив всех переводов и искать в нём по индексу

**Вопрос 9**

Какую концепцию наследования в JavaScript демонстрирует код ниже?

1 function A() {}  
2 A.prototype.shared \= 'value';  
3 function B() {}  
4 B.prototype \= Object.create(A.prototype);  
5 B.prototype.unique \= 'another';  
6 const b \= new B();

1. Поверхностное наследование  
2. Цепочка прототипов вручную  
3. Инкапсуляция на уровне объекта  
4. Формальное клонирование  
5. Наследование свойств

**Вопрос 10**

Что происходит, когда у объекта в JavaScript запрашивается свойство, которого у него нет?

1. Происходит возврат к значению по умолчанию из конструктора  
2. JavaScript создает это свойство автоматически  
3. Объект возвращает undefined, если свойства нет  
4. Объект возвращает null, если свойства нет  
5. Вызывается исключение

**Вопрос 11**

Что произойдет при выполнении кода?

1 function createCounter() {  
2   let count \= 0;  
3   return {  
4     increment() {  
5       count++;  
6       return count;  
7     }  
8   };  
9 }  
10 const counter \= createCounter();  
11 console.log(counter.increment());

1. Создается глобальная переменная count и метод increment у counter, который увеличивает count  
2. Метод increment использует замыкание для доступа к count и увеличивает его  
3. Каждый вызов increment возвращает 1, так как заново создается count и увеличивается на 1  
4. count становится недоступным после первой итерации  
5. Функция createCounter ничего не возвращает

**Вопрос 12**

Что возвращает вызов fetch()?

1. Результат сетевого запроса в виде объекта JSON, доступного без дополнительных вызовов  
2. Функцию, возвращающую результат сетевого вызова при вызове с параметрами запроса  
3. Объект, позволяющий отследить статус операции и обработать её результат после завершения  
4. Синхронную структуру, описывающую заголовки и тело HTTP-ответа сервера запроса  
5. Статический объект, отражающий параметры и конфигурацию сетевого соединения клиента