# **JS\_advanced**

**Вопрос 1**

Какой результат будет выведен в консоль после выполнения следующего кода?

1 var message \= "Hello";  
2 function sayHi() {  
3   let message \= "Hi";  
4   if (true) {  
5     var message \= "Hey";  
6   }  
7   console.log(message);  
8 }  
9 sayHi();  
10 console.log(message);

1. "Hi", "Hello"  
2. "Hey", "Hey"  
3. "Hey", "Hello"  
4. Будет ошибка  
5. "Hi", "Hey"

**Вопрос 2**

В современном веб\-приложении социальной сети необходимо сохранять не только базовые настройки пользователя, но и сложные объекты (например, параметры отображения, избранный контент и настройки приватности). Данные должны храниться локально, поддерживать транзакционную целостность и масштабироваться с ростом объема информации, при этом не требуя постоянного обмена с сервером.

Какой тип хранилища вы подберете для данной задачи?

1. sessionStorage  
2. Cookies  
3. IndexedDB  
4. Web SQL Database  
5. LocalStorage

**Вопрос 3**

Каким будет результат выполнения следующего выражения в JavaScript?

1 3 \+ 4 \+ "5" \- 2

1. 10  
2. '345'  
3. 73  
4. 9  
5. '75'

**Вопрос 4**

Какой вариант кода удаляет дублирующиеся числа из массива, умножает оставшиеся на 10 и вычисляет их сумму?

1. \[...new Set(numbers)\].map(n \=\> n \* 10).reduce((s, n) \=\> s \+ n, 0\)  
2. \[...numbers\].filter((n, i, arr) \=\> arr.indexOf(n) \=== i).map(n \=\> n \* 10).reduce((s, n) \=\> s \+ n, 0\)  
3. numbers.reduce((s, n) \=\> s \+ n ? \[...s, n \* 10\] : s, \[\]).reduce((a, b) \=\> a \+ b, 0\)  
4. numbers.filter((n, i, arr) \=\> arr.indexOf(n) \=== i).map(n \=\> n \* 10).reduce((s, n) \=\> s \+ n, 0\)  
5. numbers.filter(n \=\> n \=== n).map(n \=\> n \* 10).reduce((s, n) \=\> s \+ n, 0\)

**Вопрос 5**

Какая разновидность функции, будучи анонимной, может присваиваться переменной и при этом сохранять доступ к локальной области видимости за счёт замыкания?

1. Функция обратного вызова (callback function)  
2. Генераторная функция (generator function)  
3. Функциональное выражение (function expression)  
4. Функция-конструктор (constructor function)  
5. Самовызывающаяся функция (IIFE)

**Вопрос 6**

Что будет выведено в консоль при выполнении данного кода?

1 function createLoggers() {  
2   var loggers \= \[\];  
3   for (var i \= 0; i \< 3; i++) {  
4     loggers.push(function() {  
5       return i;  
6     });  
7   }  
8   return loggers;  
9 }  
10 const \[loggerA, loggerB, loggerC\] \= createLoggers();  
11 console.log(loggerA());  
12 console.log(loggerB());  
13 console.log(loggerC());

1. 1,2,3  
2. 3,3,3  
3. 2,2,2  
4. 0,0,0  
5. undefined, undefined, undefined

**Вопрос 7**

В какой последовательности выполняются операции в следующем коде, который включает асинхронные операции и взаимодействие с сетью? Учтите, что обработка запроса не будет закончена до того, как выполнится весь синхронный код программы.

1 console.log("Log A");  
2 setTimeout(() \=\> {  
3   console.log("Timeout 200ms");  
4 }, 200);  
5 fetch("https://api.example.com/check")  
6   .then(() \=\> {  
7     console.log("Fetch check");  
8   });  
9 setTimeout(() \=\> {  
10   console.log("Timeout 0ms");  
11 }, 0);  
12 console.log("Log B");

1. Log A, Log B, Timeout 200ms, Timeout 0ms, Fetch check  
2. Log A, Log B, Timeout 200ms, Fetch check, Timeout 0ms  
3. Log A, Fetch check, Log B, Timeout 0ms, Timeout 200ms  
4. Log A, Log B, Timeout 0ms, Timeout 200ms, Fetch check  
5. Log B, Log A, Timeout 0ms, Fetch check, Timeout 200ms

**Вопрос 8**

Какое из следующих утверждений о методе Object.assign() является верным?

1. Object.assign() выполняет глубокое копирование всех вложенных объектов по умолчанию, обеспечивая независимость копий от оригинала  
2. Object.assign() автоматически удаляет свойства, содержащие функции, если они присутствуют в исходном объекте, так как методы не могут быть скопированы  
3. Object.assign() копирует свойства из одного или нескольких исходных объектов в целевой объект, перезаписывая совпадающие свойства  
4. Object.assign() выбрасывает ошибку, если целевой объект (target) уже содержит свойство с таким же именем, так как не может перезаписывать существующие значения  
5. Object.assign() объединяет только свойства, у которых тип равен string; все остальные типы игнорируются

**Вопрос 9**

Вы хотите объединить свойства двух объектов и элементы двух массивов, при этом для объектов нужно сохранить методы, хранящиеся как собственные свойства, а для массивов исключить дубликаты. Как лучше всего добиться этого?

1. const mergedObj \= Object.assign(obj1, obj2); const mergedArr \= arr1.push(...arr2);  
2. const mergedObj \= {...obj1, ...obj2}; const mergedArr \= \[...new Set(\[...arr1, ...arr2\])\];  
3. const mergedObj \= JSON.parse(JSON.stringify(obj1, obj2)); const mergedArr \= \[...arr1, ...arr2\];  
4. const mergedObj \= {...obj1}; mergedObj.\_\_proto\_\_ \= obj2; const mergedArr \= Array.from(new Set(\[...arr1, ...arr2\]));  
5. const mergedObj \= Object.create(obj2, Object.getOwnPropertyDescriptors(obj1)); const mergedArr \= \[...new Set(\[...arr1, ...arr2\])\];

**Вопрос 10**

У вас есть следующий код. Что будет выведено в консоль при его вызове?

1 class MyArray extends Array {  
2   constructor(...elements) {  
3     super(...elements);  
4     this.extra \= elements.length \> 0 ? elements\[0\] \* 2 : 0;  
5   }  
6  
7   lastElement() {  
8     return this.at(-1);  
9   }  
10  
11   static fromArray(arr) {  
12     return new MyArray(...arr.filter(el \=\> el % 2 \=== 0));  
13   }  
14 }  
15  
16 const arr \= new MyArray(5, 10, 15, 20);  
17 const arr2 \= MyArray.fromArray(\[1, 2, 3, 4, 5, 6\]);  
18 console.log(arr instanceof Array);  
19 console.log(arr.lastElement());  
20 console.log(arr.extra);  
21 console.log(arr2.length);  
22 console.log(Object.getPrototypeOf(arr) \=== MyArray.prototype);  
23 console.log(Array.isArray(arr2));

1. false, 20, 10, 3, false, false \- наследование от Array работает некорректно, instanceof не срабатывает, а lastElement() не видит отрицательный индекс  
2. true, undefined, 5, 3, true, true \- метод lastElement() не работает, так как at(-1) не поддерживается на расширенных массивах, а extra хранит оригинальный первый элемент  
3. Ошибка TypeError: Cannot call method 'at' of undefined \- метод at(-1) ломается на экземплярах классов, унаследованных от Array, при вызове lastElement()  
4. true, 20, 10, 3, true, true \- класс работает корректно, arr наследуется от Array, lastElement() использует at(-1), extra \- удвоенный первый элемент, fromArray фильтрует чётные  
5. true, 15, 5, 3, true, true \- lastElement() возвращает неправильный элемент, extra содержит исходное значение вместо удвоенного, что делает реализацию некорректной

**Вопрос 11**

На странице со списком пользователей при прокрутке возникают лаги из\-за многочисленных событий scroll. Как можно сократить влияние этих событий на производительность и сделать работу интерфейса плавнее?

1. Добавить постоянную подписку на все события scroll, обрабатывая каждое изменение положения прокрутки немедленно  
2. Применять debounce или throttle для обработчиков прокрутки, снижая частоту вызовов и нагрузку  
3. Создать дополнительный таймер, который чистит события scroll каждые 5 секунд  
4. Выделять отдельный DOM-элемент под каждую строку списка, даже если она не видна пользователю  
5. Отказаться от прокрутки и использовать постраничную навигацию с огромными кнопками «Далее» и «Назад»

**Вопрос 12**

Оцените влияние Promise и setTimeout в следующем коде. Какие утверждения корректны?

1 console.log(1);  
2 Promise.resolve()  
3   .then(() \=\> {  
4     console.log(2);  
5     return Promise.resolve(3);  
6   })  
7   .then(val \=\> {  
8     console.log(val);  
9     setTimeout(() \=\> {  
10       console.log(4);  
11     }, 0);  
12   });  
13 setTimeout(() \=\> {  
14   console.log(5);  
15 }, 0);  
16 console.log(6);

1. 2 и 3 выведутся до 5, потому что Promise.then идёт раньше setTimeout  
2. Код может выбросить ошибку, если val окажется undefined  
3. 4 и 5 могут поменяться местами в зависимости от браузера  
4. Вложенный setTimeout имеет более высокий приоритет, чем внешний  
5. 3 будет выведено синхронно, так как передано напрямую

**Вопрос 13**

Для чего используется Hot Module Replacement в Webpack?

1. Для автоматического удаления неиспользуемого и дублирующегося кода при сборке проекта  
2. Для генерации расширенного отчёта о зависимостях и внутренней структуре проекта.  
3. Для обновления измененных модулей без полной перезагрузки страницы, что ускоряет процесс разработки  
4. Для динамической загрузки модулей во время выполнения без необходимости полной компиляции  
5. Для уменьшения размера финального бандла за счет агрессивной оптимизации

**Вопрос 14**

Как реализовать делегирование событий для динамически добавленных элементов, чтобы при клике на любой из них сработал единый обработчик?

1. Использовать jQuery метод on(), передавая родительский селектор и тип события для правильного делегирования  
2. Применить метод element.delegateEvent(), позволяющий автоматически перенаправлять события к родительскому элементу  
3. Назначить обработчик на родителя через addEventListener и внутри него проверять event.target  
4. Использовать метод document.write() для вставки обработчика в HTML-код  
5. Привязывать обработчик индивидуально каждому новому элементу через свойство onclick

**Вопрос 15**

В вашем SPA (Single Page Application) имеется множество компонентов, не критичных для первичного отображения, загрузка которых замедляет рендер. Вы планируете загружать их только при непосредственном взаимодействии пользователя с приложением.

Какой метод вы используете для достижения этой цели?

1. Server-Side Rendering (SSR), чтобы предварительно рендерить HTML на сервере и ускорить загрузку контента  
2. Использование Web Workers для фоновых задач, чтобы переместить вычисления в отдельный поток и избежать зависаний интерфейса  
3. Динамическое разделение кода, чтобы разбить приложение на модули и управлять загрузкой частей кода по мере необходимости  
4. Кэширование API ответов в IndexedDB, чтобы сохранять данные локально и уменьшить количество сетевых запросов  
5. Техника Lazy Loading для модулей, чтобы загружать компоненты только при их использовании и снизить нагрузку на клиент