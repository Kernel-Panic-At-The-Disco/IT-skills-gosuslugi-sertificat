# OOP_advanced

---

## Вопрос 1
Какой из следующих вариантов наиболее полно и точно отражает концепцию наследования в объектно-ориентированном программировании?

- Наследование позволяет создавать иерархию классов, где дочерние классы могут наследовать методы и свойства родителя, но при этом ограничивает возможность переопределения их поведения, обеспечивая строгую типизацию  
- Наследование предполагает возможность передачи только статических методов и атрибутов между классами, исключая динамические аспекты и полиморфизм из данного процесса  
- Наследование требует от дочерних классов полного дублирования методов и атрибутов родительского класса для достижения согласованности в реализации, что может привести к избыточности кода  
- Наследование подразумевает использование принципов композиции для передачи данных между объектами, что ведет к уменьшению сложности и улучшению читаемости кода, избегая многократного использования одного и того же кода  
- Наследование предоставляет дочерним классам возможность не только заимствовать и переопределять методы родительского класса, но и расширять функциональность

---

## Вопрос 2
В каком из следующих случаев принцип инкапсуляции применяется корректно и эффективно с точки зрения архитектуры объектно-ориентированной системы?

- Класс User имеет private поле email и публичный геттер отдаёт значение по ссылке  
- Класс Logger реализует статические методы логирования, доступные из любого места программы без создания экземпляра.  
- Класс Account предоставляет публичные методы withdraw() и deposit(), а доступ к балансу осуществляется исключительно внутри этих методов, без прямого изменения извне  
- В классе Vehicle все поля private, но для каждого из них создан отдельный публичный геттер и сеттер без какой-либо проверки или ограничения  
- Класс UserProfile хранит поля email и password как private, а доступ к ним осуществляется через открытые геттеры и сеттеры, которые напрямую возвращают и изменяют значения

---

## Вопрос 3
Среди приведенных вариантов ответа выберите тот, который наиболее точно отражает назначение поведенческих паттернов в объектно-ориентированном программировании.

- Эти паттерны применяются для управления состоянием объекта, устанавливая строгие ограничения на его методы  
- Эти паттерны ориентированы на создание структурированных классов с фиксированным набором методов и атрибутов  
- Поведенческие паттерны требуют, чтобы все методы были статическими и не зависели от состояния объекта  
- Поведенческие паттерны помогают создавать гибкие интерфейсы, позволяя объектам менять свои методы в зависимости от условий  
- Поведенческие паттерны описывают, как объекты взаимодействуют и распределяют ответственность между собой внутри программы

---

## Вопрос 4
Какой из принципов SOLID нарушен в данном коде?

1 Класс «Банк»:  
2   инициализация объекта (имя, баланс):  
3     объект.имя \= имя  
4     объект.баланс \= баланс  
5   создать\_счет (тип\_счета):  
6     если тип\_счета \== "сберегательный":  
7       вернуть СберегательныйСчет(объект)  
8     иначе:  
9       вернуть ТекущийСчет(объект)  
10 Интерфейс «Счет»:  
11   метод открыть()  
12 Класс «СберегательныйСчет» реализует «Счет»:  
13   инициализация объекта (банк):  
14     объект.банк \= банк  
15   метод открыть():  
16     вывести "открыт сберегательный счёт"  
17 Класс «ТекущийСчет» реализует «Счет»:  
18   инициализация объекта (банк):  
19     объект.банк \= банк  
20   метод открыть():  
21     вывести "Открыт текущий счёт"

- Принцип инверсии зависимостей (DIP)  
- Принцип единственной ответственности (SRP)  
- Принцип разделения интерфейса (ISP)  
- Принцип открытости/закрытости (OCP)  
- Принцип подстановки Барбары Лисков (LSP)

---

## Вопрос 5
Какой из следующих методов в данном коде нарушает принципы инкапсуляции?

1 Класс «Машина»:  
2   инициализация объекта (модель, год):  
3     объект.\_модель \= модель  
4     объект.\_год \= год  
5   получить\_информацию():  
6     вернуть объект.\_модель \+ " " \+ объект.\_год  
7   изменить\_модель (новая\_модель):  
8     объект.\_модель \= новая\_модель  
9   показать\_год():  
10     вернуть объект.\_год

- показать\_год  
- год  
- получить\_информацию  
- изменить\_модель  
- инициализация

---

## Вопрос 6
Какое из следующих утверждений наиболее точно отражает принципы работы с абстрактными классами и методами в объектно-ориентированном программировании, учитывая их роль в создании иерархий классов и реализации полиморфизма?

- Абстрактные методы в абстрактном классе могут содержать как частичную, так и полную реализацию, предоставляя подклассам возможность переопределять их поведение или использовать исходную реализацию  
- Абстрактный класс служит основой для других классов, позволяя определять общие характеристики и поведение, но не обязывая их к реализации всех методов в своем теле  
- Конструкторы в абстрактных классах не предусмотрены, поскольку такие классы предназначены исключительно для задания интерфейса и не могут быть инстанцированы  
- Все методы в абстрактном классе должны быть абстрактными, однако допускается наличие статических методов, которые могут быть реализованы в самом классе  
- Объекты абстрактного класса могут быть созданы напрямую, если в классе присутствует хотя бы один метод с полной реализацией, что позволяет создавать частично определенные экземпляры

---

## Вопрос 7
Вы разрабатываете систему управления персоналом, в которой важно отслеживать общее количество сотрудников в реальном времени. Данные об объектах сотрудников реализуются через класс Employee, отвечающий за информацию об отдельном человеке. Ваша задача реализовать подсчёт общего количества сотрудников без нарушения принципов инкапсуляции и единственной ответственности.

Какой подход будет наилучшим?

- Добавить переменную класса count в Employee, но обращаться к ней только через внешний модуль учёта  
- Встроить счётчик в базу данных и получать значение через SQL-запрос  
- Делегировать ответственность подсчёта объекту HRManager, который добавляет сотрудников в систему  
- Вынести подсчёт сотрудников в отдельный класс EmployeeRegistry, который управляет созданием и хранением всех сотрудников  
- Добавить в класс Employee статическое поле и метод для ведения общего счёта сотрудников

---

## Вопрос 8
Вы разрабатываете модуль для управления уведомлениями. Уведомления могут отправляться по электронной почте, в SMS или в push-формате. У всех уведомлений должен быть метод отправить(). Некоторые типы уведомлений (например, email) поддерживают вложения. Как следует организовать классы, чтобы соблюсти принципы наследования, масштабируемости и минимальной связанности?

- Создать общий интерфейс Notifiable с методом отправить() и дополнительный интерфейс Attachable, который реализуют только те классы, где поддерживаются вложения  
- Реализовать абстрактный класс Notification, включающий методы отправить() и прикрепить\_файл(), даже если вложения нужны не для всех форматов  
- Сделать интерфейс Notifiable с методами отправить() и прикрепить\_файл(), и все классы должны реализовать оба метода  
- Создать класс EmailNotification с полной реализацией и от него унаследовать SmsNotification и PushNotification  
- Объединить всю логику отправки в один универсальный класс NotificationHandler, переключаясь между типами уведомлений по флагу

---

## Вопрос 9
В процессе разработки системы для управления различными типами платежей в интернет-магазине вам нужно реализовать обработку различных форм оплаты.

Какой из следующих подходов лучше всего иллюстрирует применение полиморфизма на практике?

- Использование единственного класса PaymentProcessor, который содержит все методы для обработки различных типов платежей без разделения на конкретные классы  
- Реализация метода processPayment() в каждом классе CreditCardPayment, PayPalPayment и BitcoinPayment, но без общего базового класса  
- Создание базового класса Payment с абстрактным методом processPayment(), который будет реализован в подклассах, позволяя каждому классу иметь свою реализацию обработки платежа  
- Создание интерфейса PaymentMethod, который содержит только методы для получения информации о платеже, но не включает их обработку, не используя полиморфизм для обработки платежей  
- Определение метода processPayment() в классе ShoppingCart, который обрабатывает все типы платежей

---

## Вопрос 10
Какие факторы могут привести к ухудшению связанности кода в объектно-ориентированном программировании?

- Построение системы с минимальным количеством зависимостей между классами для повышения гибкости  
- Наследование от общего базового класса с последующим переопределением всех методов в каждом подклассе  
- Применение паттернов проектирования для ослабления зависимости между компонентами  
- Внедрение зависимостей через статические вспомогательные классы, общие для нескольких компонентов  
- Жесткое связывание классов через непосредственные вызовы методов и обмен данными напрямую

---

## Вопрос 11
Какой из следующих вариантов наиболее точно описывает процесс сериализации объекта в ООП?

- Преобразование объекта в строку для передачи его через интернет с сопутствующим сжатием информации  
- Преобразование объекта в числовой ход для быстрой обработки в процессоре  
- Преобразование объекта в массив для удобного хранения в памяти и равномерного распределения памяти между частями объекта  
- Преобразование объекта в поток байтов или текстовый формат для последующей передачи или сохранения  
- Преобразование объекта в другой класс для изменения его функциональности с сохранением базовых функций и методов

---

## Вопрос 12
Какая особенность характеризует объектно-ориентированные языки программирования, такие как Python, Java и C++? Выберите наиболее точный ответ, дополняющий фразу «Все они...»

- Используют только статическую типизацию для создания объектов и абстрактные классы  
- Поддерживают переопределение операторов и методов через наследование и перегрузку  
- Поддерживают создание пользовательских типов данных, классов и объектов в них  
- Используют обязательную обработку исключений и действий с ошибками, при создании объекта класса  
- Поддерживают множественное наследование классов, сохраняя методы и атрибуты всех родительских классов

---

## Вопрос 13
Какой набор принципов ООП лежит в основе ситуации, когда разработчик описывает структуру поведения для набора объектов, не задавая его конкретную реализацию, но ожидая, что она будет добавлена в специализированных классах?

- Принцип абстракции и полиморфизма, который позволяет создавать интерфейсы для различных типов объектов и их реализаций  
- Принцип композиции и делегирования, позволяющий создавать сложные объекты за счет комбинирования простых объектов  
- Принцип множественного наследования и методов, который позволяет классам наследовать методы от нескольких других классов  
- Принцип инкапсуляции и статической типизации, где классы могут скрывать свои данные, но все типы должны быть определены заранее  
- Принцип единственной ответственности и наследования, где классы имеют только одну задачу и могут расширять функциональность через наследование

---

## Вопрос 14
Какое из следующих описаний наиболее точно и всесторонне отражает сущность объектно-ориентированного программирования (ООП), учитывая его ключевые принципы и влияние на проектирование сложных программных систем?

- Программная парадигма, которая интегрирует концепции классов, объектов и методов в единое целое, позволяющее реализовывать сложные системы с возможностью динамической адаптации и масштабируемости  
- Технология разработки программного обеспечения, основная цель которой заключается в улучшении модульности кода путем создания независимых и изолированных классов, взаимодействующих между собой  
- Методология программирования, основанная на концептуализации реальных сущностей как объектов, их взаимодействии через интерфейсы, а также наследовании в контексте классов и аргументов  
- Способ организации кода, при котором данные и методы объединяются в одном объекте, что упрощает описание реальных сущностей  
- Система проектирования программного обеспечения, акцентирующая внимание на повторное использование компонентов через интерфейсы и классы, обеспечивающая минимизацию дублирования кода

---

## Вопрос 15
Какой из следующих аспектов наиболее точно и всесторонне описывает ключевые характеристики объектно-ориентированных баз данных (ООБД), учитывая их структуру, управление данными и взаимодействие с объектами?

- ООБД позволяют сохранять данные в виде объектов, содержащих как методы, так и уникальные свойства, что значительно упрощает работу с комплексными данными и их отношениями  
- ООБД не поддерживают транзакции и многозадачность в работе с данными, что ограничивает их применение в высоконагруженных системах  
- ООБД хранят данные в табличной форме, используя SQL-запросы и реляционные связи, что ограничивает гибкость в моделировании сложных объектов  
- ООБД поддерживают только один тип отношений между объектами — однонаправленную связь, что усложняет работу с более сложными структурами данных  
- ООБД не используют агрегатные функции для анализа данных, поскольку они полагаются исключительно на встроенные методы и свойства объектов для извлечения информации

---

## Вопрос 16
Какой из следующих вариантов наиболее точно отражает механизм освобождения ресурсов и завершение жизненного цикла объекта в контексте объектно-ориентированного программирования?

- Освобождение ресурсов происходит только для объектов, созданных в динамической памяти, инициализированных с использованием низкоуровневых операторов управления памятью  
- Деструктор активируется автоматически для объектов, наследующих от базового класса, и управляет очисткой ресурсов, выделенных как родительским, так и дочерним классом  
- Деструктор предоставляет возможность выполнить завершающие операции, такие как очистка атрибутов объекта, перед его удалением из памяти или завершением выполнения метода класса  
- Процесс деструкции объекта осуществляется при выходе из области видимости, освобождая все ресурсы, занятые им  
- Деструктор — неявный метод, который активируется только при явном вызове и предназначен для освобождения ресурсов, переданных объекту через конструктор  

---

## Вопрос 17
В каком случае корректно реализуется принцип абстракции как средство управления сложностью в объектно-ориентированном программировании?

- Абстрактный класс Shape определяет метод draw() без реализации, а конкретные фигуры (Circle, Square) реализуют его по-разному  
- Класс DatabaseConnection предоставляет метод connect(), но скрывает, какие именно параметры подключения использует и каким образом устанавливается соединение  
- Класс User содержит все поля в виде private, и доступ к ним осуществляется только через геттеры и сеттеры  
- Класс Logger реализован как синглтон и управляется через глобальную точку доступа  
- Методы всех бизнес-объектов объявлены публичными для обеспечения простоты тестирования и интеграции  

---

## Вопрос 18
Какое из следующих утверждений лучше всего описывает влияние поведенческих паттернов на проектирование системы?

- Поведенческие паттерны жестко связывают методы объектов, что позволяет избежать сложных зависимостей  
- Поведенческие паттерны минимизируют количество классов, позволяя реализовывать всю функциональность в одном объекте  
- Поведенческие паттерны используются для создания сложных иерархий классов, что упрощает управление проектом  
- Эти паттерны помогают упрощать взаимодействие между объектами, увеличивая гибкость и расширяемость кода  
- Они уменьшают количество методов в классе, делая его более понятным и легким для поддержки  

---

## Вопрос 19
Какой модификатор доступа следует использовать, чтобы обеспечить доступность полей и методов класса из самого класса, из производного класса и из других классов в той же сборке, но не из других сборок?

- Public  
- Protected  
- Public Internal  
- Private  
- Protected Internal  

---

## Вопрос 20
Если несколько интерфейсов, реализованных абстрактным классом, содержат одинаковые методы...

- Конфликт возникнет в некоторых языках программирования, где запрещено неявное множественное наследование  
- Это не вызывает конфликта: класс предоставляет единственную реализацию этого метода, и она будет удовлетворять всем интерфейсам  
- Это не вызывает конфликта: абстрактный класс автоматически наследует реализацию метода из первого интерфейса и игнорирует остальные  
- Это вызовет конфликт: в абстрактном классе возникнет ошибка компиляции из-за конфликта имен методов  
- Это не вызывает конфликта: компилятор создает адаптеры для методов, чтобы избежать конфликта  

---

## Вопрос 21
Вам нужно разработать приложение для интернет-магазина. Класс "Order" содержит методы для добавления товаров и расчёта общей стоимости. Все заказы облагаются налогом по единому правилу.

Как следует организовать расчет налога, чтобы соблюсти принципы объектно-ориентированного проектирования?

- Реализовать метод calculate_tax() в каждом конкретном подклассе заказа, даже если логика одинакова  
- Создать отдельный класс "TaxCalculator", который будет принимать объект "Order" и возвращать сумму налога  
- Вызвать расчёт налога прямо в конструкторе "Order", чтобы налог рассчитывался при создании объекта  
- Сделать метод calculate_tax() приватным в классе "Order", чтобы ограничить его доступ для других компонентов  
- Добавить метод calculate_tax() в класс "Order" как статический, чтобы не требовалось создавать экземпляр  

---

## Вопрос 22
Вы проектируете систему оплаты для интернет-магазина. У вас есть классы BankCard, PayPal, CryptoWallet, которые реализуют методы оплаты. Вы хотите обеспечить возможность добавления новых способов оплаты без изменения существующего кода.

Какой из следующих подходов будет подходящим с точки зрения наследования и масштабируемости?

- Сделать класс PayPal базовым, а BankCard и CryptoWallet – его наследниками, чтобы переиспользовать реализацию  
- Создать интерфейс Payable с методом pay(), который реализуют все классы оплаты, независимо от их внутренней логики  
- Реализовать каждый способ оплаты в отдельном классе без общего интерфейса или базового класса, чтобы избежать связей между ними  
- Объединить все способы оплаты в один класс PaymentProcessor, добавляя флаг, указывающий тип оплаты  
- Создать абстрактный класс PaymentMethod, от которого наследуются все способы оплаты, включая реализацию общего метода pay()  

---

## Вопрос 23
Динамический полиморфизм достигается в основном с помощью...

- Абстрактных классов  
- Множественного наследования  
- Виртуальных методов  
- Шаблонов  
- Наследования  

---

## Вопрос 24
Выберите НЕПОДХОДЯЩИЙ вариант продолжения тезиса:

Снижение сильной связанности классов в иерархии наследования можно достигнуть с помощью...

- Применения принципов композиции вместо наследования  
- Использования модификаторов доступа  
- Использования статических классов  
- Применения принципа инверсии управления  
- Использования интерфейсного наследования  

---

## Вопрос 25
Какое из следующих утверждений наиболее точно описывает полиморфизм в объектно-ориентированных языках программирования, таких как Python, Java, C++ и JavaScript?

- Полиморфизм обозначает строгое следование типам данных без возможности их изменения, как в Java  
- Полиморфизм исключает возможность переопределения методов, что не реализовано в Python и JavaScript  
- Полиморфизм позволяет использовать один и тот же интерфейс для работы с различными типами объектов  
- Полиморфизм применяется только в контексте наследования методов и атрибутов  
- Полиморфизм требует создания нового класса для каждого типа объекта  

---

## Вопрос 26
Выберите верное суждение о компонентно-ориентированном программировании.

- Основная идея концепции – создание программных компонентов, которые могут быть использованы в разных приложениях  
- Компонентно-ориентированное программирование направлено прежде всего на повышение надежности закрытых статических систем  
- Особенность компонентно-ориентированного программирования – создание прототипов объектов, которые могут быть клонированы и изменены  
- Компонентно-ориентированное программирование – один из видов класс-ориентированного программирования  
- Сходство агентов и компонентно-ориентированного программирования – в создании агентов, которые могут взаимодействовать друг с другом и с окружающей средой