# **OOP\_advanced**

**Вопрос 1**

Какой из следующих вариантов наиболее полно и точно отражает концепцию наследования в объектно-ориентированном программировании?

1. Наследование позволяет создавать иерархию классов, где дочерние классы могут наследовать методы и свойства родителя, но при этом ограничивает возможность переопределения их поведения, обеспечивая строгую типизацию  
2. Наследование предполагает возможность передачи только статических методов и атрибутов между классами, исключая динамические аспекты и полиморфизм из данного процесса  
3. Наследование требует от дочерних классов полного дублирования методов и атрибутов родительского класса для достижения согласованности в реализации, что может привести к избыточности кода  
4. Наследование подразумевает использование принципов композиции для передачи данных между объектами, что ведет к уменьшению сложности и улучшению читаемости кода, избегая многократного использования одного и того же кода  
5. Наследование предоставляет дочерним классам возможность не только заимствовать и переопределять методы родительского класса, но и расширять функциональность

**Вопрос 2**

В каком из следующих случаев принцип инкапсуляции применяется корректно и эффективно с точки зрения архитектуры объектно-ориентированной системы?

1. Класс User имеет private поле email и публичный геттер отдаёт значение по ссылке  
2. Класс Logger реализует статические методы логирования, доступные из любого места программы без создания экземпляра.  
3. Класс Account предоставляет публичные методы withdraw() и deposit(), а доступ к балансу осуществляется исключительно внутри этих методов, без прямого изменения извне  
4. В классе Vehicle все поля private, но для каждого из них создан отдельный публичный геттер и сеттер без какой-либо проверки или ограничения  
5. Класс UserProfile хранит поля email и password как private, а доступ к ним осуществляется через открытые геттеры и сеттеры, которые напрямую возвращают и изменяют значения

**Вопрос 3**

Среди приведенных вариантов ответа выберите тот, который наиболее точно отражает назначение поведенческих паттернов в объектно-ориентированном программировании.

1. Эти паттерны применяются для управления состоянием объекта, устанавливая строгие ограничения на его методы  
2. Эти паттерны ориентированы на создание структурированных классов с фиксированным набором методов и атрибутов  
3. Поведенческие паттерны требуют, чтобы все методы были статическими и не зависели от состояния объекта  
4. Поведенческие паттерны помогают создавать гибкие интерфейсы, позволяя объектам менять свои методы в зависимости от условий  
5. Поведенческие паттерны описывают, как объекты взаимодействуют и распределяют ответственность между собой внутри программы

**Вопрос 4**

Какой из принципов SOLID нарушен в данном коде?

1 Класс «Банк»:  
2   инициализация объекта (имя, баланс):  
3     объект.имя \= имя  
4     объект.баланс \= баланс  
5   создать\_счет (тип\_счета):  
6     если тип\_счета \== "сберегательный":  
7       вернуть СберегательныйСчет(объект)  
8     иначе:  
9       вернуть ТекущийСчет(объект)  
10 Интерфейс «Счет»:  
11   метод открыть()  
12 Класс «СберегательныйСчет» реализует «Счет»:  
13   инициализация объекта (банк):  
14     объект.банк \= банк  
15   метод открыть():  
16     вывести "открыт сберегательный счёт"  
17 Класс «ТекущийСчет» реализует «Счет»:  
18   инициализация объекта (банк):  
19     объект.банк \= банк  
20   метод открыть():  
21     вывести "Открыт текущий счёт"

1. Принцип инверсии зависимостей (DIP)  
2. Принцип единственной ответственности (SRP)  
3. Принцип разделения интерфейса (ISP)  
4. Принцип открытости/закрытости (OCP)  
5. Принцип подстановки Барбары Лисков (LSP)

**Вопрос 5**

Какой из следующих методов в данном коде нарушает принципы инкапсуляции?

1 Класс «Машина»:  
2   инициализация объекта (модель, год):  
3     объект.\_модель \= модель  
4     объект.\_год \= год  
5   получить\_информацию():  
6     вернуть объект.\_модель \+ " " \+ объект.\_год  
7   изменить\_модель (новая\_модель):  
8     объект.\_модель \= новая\_модель  
9   показать\_год():  
10     вернуть объект.\_год

1. показать\_год  
2. год  
3. получить\_информацию  
4. изменить\_модель  
5. инициализация

**Вопрос 6**

Какое из следующих утверждений наиболее точно отражает принципы работы с абстрактными классами и методами в объектно-ориентированном программировании, учитывая их роль в создании иерархий классов и реализации полиморфизма?

1. Абстрактные методы в абстрактном классе могут содержать как частичную, так и полную реализацию, предоставляя подклассам возможность переопределять их поведение или использовать исходную реализацию  
2. Абстрактный класс служит основой для других классов, позволяя определять общие характеристики и поведение, но не обязывая их к реализации всех методов в своем теле  
3. Конструкторы в абстрактных классах не предусмотрены, поскольку такие классы предназначены исключительно для задания интерфейса и не могут быть инстанцированы  
4. Все методы в абстрактном классе должны быть абстрактными, однако допускается наличие статических методов, которые могут быть реализованы в самом классе  
5. Объекты абстрактного класса могут быть созданы напрямую, если в классе присутствует хотя бы один метод с полной реализацией, что позволяет создавать частично определенные экземпляры

**Вопрос 7**

Вы разрабатываете систему управления персоналом, в которой важно отслеживать общее количество сотрудников в реальном времени. Данные об объектах сотрудников реализуются через класс Employee, отвечающий за информацию об отдельном человеке. Ваша задача реализовать подсчёт общего количества сотрудников без нарушения принципов инкапсуляции и единственной ответственности.

Какой подход будет наилучшим?

1. Добавить переменную класса count в Employee, но обращаться к ней только через внешний модуль учёта  
2. Встроить счётчик в базу данных и получать значение через SQL-запрос  
3. Делегировать ответственность подсчёта объекту HRManager, который добавляет сотрудников в систему  
4. Вынести подсчёт сотрудников в отдельный класс EmployeeRegistry, который управляет созданием и хранением всех сотрудников  
5. Добавить в класс Employee статическое поле и метод для ведения общего счёта сотрудников

**Вопрос 8**

Вы разрабатываете модуль для управления уведомлениями. Уведомления могут отправляться по электронной почте, в SMS или в push-формате. У всех уведомлений должен быть метод отправить(). Некоторые типы уведомлений (например, email) поддерживают вложения. Как следует организовать классы, чтобы соблюсти принципы наследования, масштабируемости и минимальной связанности?

1. Создать общий интерфейс Notifiable с методом отправить() и дополнительный интерфейс Attachable, который реализуют только те классы, где поддерживаются вложения  
2. Реализовать абстрактный класс Notification, включающий методы отправить() и прикрепить\_файл(), даже если вложения нужны не для всех форматов  
3. Сделать интерфейс Notifiable с методами отправить() и прикрепить\_файл(), и все классы должны реализовать оба метода  
4. Создать класс EmailNotification с полной реализацией и от него унаследовать SmsNotification и PushNotification  
5. Объединить всю логику отправки в один универсальный класс NotificationHandler, переключаясь между типами уведомлений по флагу

**Вопрос 9**

В процессе разработки системы для управления различными типами платежей в интернет-магазине вам нужно реализовать обработку различных форм оплаты.

Какой из следующих подходов лучше всего иллюстрирует применение полиморфизма на практике?

1. Использование единственного класса PaymentProcessor, который содержит все методы для обработки различных типов платежей без разделения на конкретные классы  
2. Реализация метода processPayment() в каждом классе CreditCardPayment, PayPalPayment и BitcoinPayment, но без общего базового класса  
3. Создание базового класса Payment с абстрактным методом processPayment(), который будет реализован в подклассах, позволяя каждому классу иметь свою реализацию обработки платежа  
4. Создание интерфейса PaymentMethod, который содержит только методы для получения информации о платеже, но не включает их обработку, не используя полиморфизм для обработки платежей  
5. Определение метода processPayment() в классе ShoppingCart, который обрабатывает все типы платежей

**Вопрос 10**

Какие факторы могут привести к ухудшению связанности кода в объектно-ориентированном программировании?

1. Построение системы с минимальным количеством зависимостей между классами для повышения гибкости  
2. Наследование от общего базового класса с последующим переопределением всех методов в каждом подклассе  
3. Применение паттернов проектирования для ослабления зависимости между компонентами  
4. Внедрение зависимостей через статические вспомогательные классы, общие для нескольких компонентов  
5. Жесткое связывание классов через непосредственные вызовы методов и обмен данными напрямую

**Вопрос 11**

Какой из следующих вариантов наиболее точно описывает процесс сериализации объекта в ООП?

1. Преобразование объекта в строку для передачи его через интернет с сопутствующим сжатием информации  
2. Преобразование объекта в числовой ход для быстрой обработки в процессоре  
3. Преобразование объекта в массив для удобного хранения в памяти и равномерного распределения памяти между частями объекта  
4. Преобразование объекта в поток байтов или текстовый формат для последующей передачи или сохранения  
5. Преобразование объекта в другой класс для изменения его функциональности с сохранением базовых функций и методов

**Вопрос 12**

Какая особенность характеризует объектно-ориентированные языки программирования, такие как Python, Java и C++? Выберите наиболее точный ответ, дополняющий фразу «Все они...»

1. Используют только статическую типизацию для создания объектов и абстрактные классы  
2. Поддерживают переопределение операторов и методов через наследование и перегрузку  
3. Поддерживают создание пользовательских типов данных, классов и объектов в них  
4. Используют обязательную обработку исключений и действий с ошибками, при создании объекта класса  
5. Поддерживают множественное наследование классов, сохраняя методы и атрибуты всех родительских классов

**Вопрос 13**

Какой набор принципов ООП лежит в основе ситуации, когда разработчик описывает структуру поведения для набора объектов, не задавая его конкретную реализацию, но ожидая, что она будет добавлена в специализированных классах?

1. Принцип абстракции и полиморфизма, который позволяет создавать интерфейсы для различных типов объектов и их реализаций  
2. Принцип композиции и делегирования, позволяющий создавать сложные объекты за счет комбинирования простых объектов  
3. Принцип множественного наследования и методов, который позволяет классам наследовать методы от нескольких других классов  
4. Принцип инкапсуляции и статической типизации, где классы могут скрывать свои данные, но все типы должны быть определены заранее  
5. Принцип единственной ответственности и наследования, где классы имеют только одну задачу и могут расширять функциональность через наследование

**Вопрос 14**

Какое из следующих описаний наиболее точно и всесторонне отражает сущность объектно-ориентированного программирования (ООП), учитывая его ключевые принципы и влияние на проектирование сложных программных систем?

1. Программная парадигма, которая интегрирует концепции классов, объектов и методов в единое целое, позволяющее реализовывать сложные системы с возможностью динамической адаптации и масштабируемости  
2. Технология разработки программного обеспечения, основная цель которой заключается в улучшении модульности кода путем создания независимых и изолированных классов, взаимодействующих между собой  
3. Методология программирования, основанная на концептуализации реальных сущностей как объектов, их взаимодействии через интерфейсы, а также наследовании в контексте классов и аргументов  
4. Способ организации кода, при котором данные и методы объединяются в одном объекте, что упрощает описание реальных сущностей  
5. Система проектирования программного обеспечения, акцентирующая внимание на повторное использование компонентов через интерфейсы и классы, обеспечивающая минимизацию дублирования кода

**Вопрос 15**

Какой из следующих аспектов наиболее точно и всесторонне описывает ключевые характеристики объектно-ориентированных баз данных (ООБД), учитывая их структуру, управление данными и взаимодействие с объектами?

1. ООБД позволяют сохранять данные в виде объектов, содержащих как методы, так и уникальные свойства, что значительно упрощает работу с комплексными данными и их отношениями  
2. ООБД не поддерживают транзакции и многозадачность в работе с данными, что ограничивает их применение в высоконагруженных системах  
3. ООБД хранят данные в табличной форме, используя SQL-запросы и реляционные связи, что ограничивает гибкость в моделировании сложных объектов  
4. ООБД поддерживают только один тип отношений между объектами — однонаправленную связь, что усложняет работу с более сложными структурами данных  
5. ООБД не используют агрегатные функции для анализа данных, поскольку они полагаются исключительно на встроенные методы и свойства объектов для извлечения информации