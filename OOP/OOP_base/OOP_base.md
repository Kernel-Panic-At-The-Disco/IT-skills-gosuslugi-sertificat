# **OOP\_base**

**Вопрос 1**

Укажите утверждение, наиболее точно описывающее разницу между классом и объектом.

1. Объект определяет структуру программы, а также процессы внутри нее, а класс является его воплощением  
2. Класс — это экземпляр функции объекта, который определяет изменяемые характеристики и атрибуты  
3. Класс это экземпляр объекта, а объект шаблон для создания классов, определяющих их методы и атрибуты  
4. Класс содержит методы и переменные, тогда как объект является конкретной реализацией этих методов и переменных  
5. Класс это программная реализация объектно-ориентированного программирования, а объект — результат работы данной программы

**Вопрос 2**

Выберите вариант, в котором верно перечислены основные принципы объектно-ориентированного программирования.

1. Объектность, инкапсуляция, наследование, полиморфизм  
2. Закрытость, инкапсуляция, декларативность, наследование  
3. Абстракция, изменяемость, полиморфизм, декларативность  
4. Абстракция, инкапсуляция, наследование, полиморфизм  
5. Наследование, полиморфизм, изменяемость, объектность

**Вопрос 3**

Какое из утверждений НЕ относится к принципам объектно-ориентированного программирования?

1. Можно единообразно обрабатывать объекты разного типа, но с общим классом или интерфейсом  
2. Контроль за доступностью свойств и методов класса обеспечивают модификаторы доступа  
3. Состояние объекта не может быть изменено после того, как объект был создан  
4. Классы определяют набор методов и атрибутов, которые будут применяться ко всем объектам этого класса  
5. Дочерние классы наследуют атрибуты и методы родительского класса

**Вопрос 4**

Имеется класс «Еда», подкласс «Фрукт» и объект «Яблоко» класса «Фрукт». Какую иерархию иллюстрирует этот пример?

1. Массив → Переменная → Значение  
2. Интерфейс → Родительский класс → Атрибут класса  
3. Класс → Экземпляр класса → Атрибут класса  
4. Класс → Интерфейс → Экземпляр класса  
5. Родительский класс → Дочерний класс → Экземпляр класса

**Вопрос 5**

Вы создаете класс «Машина» с методами «Завести», «Остановить» и «Ехать». Однако конкретные детали реализации этих методов для разных типов машин (например, бензиновых и электрических) оставляете для других классов, которые будут реализовывать этот функционал. Это пример использования какого принципа ООП?

1. Интерфейс  
2. Полиморфизм  
3. Абстракция  
4. Инкапсуляция  
5. Наследование

**Вопрос 6**

Какой метод можно переопределить в классе, чтобы предоставить собственную реализацию обработки исключений для объектов данного класса?

1. \_exception\_  
2. \_exit\_  
3. \_tryexcept\_  
4. \_handle\_  
5. \_catch\_

**Вопрос 7**

Какая из следующих характеристик отличает объектно-ориентированные языки программирования от процедурных?

1. Операции только с потоками данных и их фильтрацией  
2. Обработка объектов через строгие декларативные структуры  
3. Использование функций для разбиения программы на части  
4. Преимущественная работа с реляционными данными и классами  
5. Взаимодействие через объекты, содержащие данные и методы

**Вопрос 8**

У вас есть класс Person, у которого атрибут Age объявлен как приватный. Вы пытаетесь напрямую изменить возраст объекта, созданного на основе этого класса, но получаете ошибку.

Какое из утверждений верно?

1. Атрибут Age закрытый и доступен только для чтения внутри класса  
2. Атрибут Age можно изменить, если установить модификатор доступа Accessible вместо Protected  
3. Атрибут Age может быть изменен только при использовании программных декораторов  
4. Атрибут Age доступен только в методах подклассов или в качестве внешней функции  
5. Атрибут Age можно изменить, только унаследован его от родительского класса

**Вопрос 9**

Когда вызывается конструктор класса?

1. При наследовании одного класса от другого  
2. При создании экземпляра класса.  
3. При вызове статического метода класса.  
4. Когда класс использует перегруженный оператор  
5. Когда объект класса клонируется

**Вопрос 10**

В классе Car есть метод \_update\_speed, который является защищенным. В какой ситуации будет корректно использовать этот метод?

1. Можно вызвать только внутри метода этого же класса или подклассов  
2. Метод можно вызвать только через статический метод класса  
3. Этот метод может быть использован любым объектом любого класса  
4. Метод можно вызвать только с использованием публичных методов  
5. Можно вызывать данный метод напрямую из любого класса