# OOP_middle

---

## Вопрос 1  
Какое из утверждений верно?  

- Объект это функция, класс значение, возвращаемое этой функцией  
- Объект это шаблон, определяющий состояние и поведение классов, класс экземпляр объекта  
- Класс это имя переменной, объект значение, которое присваивается этой переменной  
- Класс это функция, объект значение, возвращаемое этой функцией  
- Класс это шаблон, определяющий состояние и поведение объектов, объект экземпляр класса  

---

## Вопрос 2  
Что из перечисленного — пример классического антипаттерна в объектно-ориентированном программировании?  

- Использование чрезмерно длинных имен методов в классах  
- Использование большого количества вложенных циклов в коде  
- Использование условных операторов со множественным ветвлением  
- Использование класса с чрезмерно большим количеством методов, имеющих разное предназначение  
- Использование индексации массива за пределами его диапазона  

---

## Вопрос 3  
Какое из утверждений наиболее точно отражает связь между абстракцией и инкапсуляцией?  

- Абстракция всегда используется с полиморфизмом, инкапсуляция с наследованием  
- Абстракция скрывает внутреннюю логику, инкапсуляция делает методы доступными  
- Абстракция работает с приватными методами, инкапсуляция управляет публичными и статическими  
- Абстракция фокусируется на классах, инкапсуляция на объектах и их методах  
- Абстракция выделяет важные аспекты, инкапсуляция скрывает детали реализации  

---

## Вопрос 4  
Что из перечисленного пример реализации статического полиморфизма?  

- Когда в классе есть несколько методов, имеющих одинаковое имя, но разное число параметров одного типа  
- Когда необходимо создать утилитарный класс класс-помощник, содержащий статические переменные и статические методы  
- Когда базовый класс имеет виртуальные методы, а дочерние классы переопределяют эти методы  
- Когда необходимо, чтобы производные классы могли переопределять методы базового класса  
- Во всех вышеперечисленных случаях  

---

## Вопрос 5  
В каком из перечисленных случаев соблюден принцип единственной ответственности?  

- Класс OrderStatusControl содержит методы для управления статусом заказа  
- Класс Order содержит методы для работы с оплатой, доставкой и управлением статусом заказа  
- Класс Payment содержит методы для работы с оплатой заказа, а класс DeliveryOrderStatusControl — для работы с доставкой и управлением статусом заказа  
- Класс Order содержит основной метод для работы с доставкой заказа и дополнительные методы для управления статусом заказа  
- Класс PaymentDelivery содержит методы для работы с оплатой и доставкой заказа  

---

## Вопрос 6  
Вы работаете в компании и создаёте программный код, который должен корректно обрабатывать ошибки и исключения. В ходе тестирования вы увидели, что программа может аварийно завершаться при возникновении ошибок. Какую конструкцию вы будете использовать для безопасного перехвата и обработки исключений?  

- Обернуть весь код в блок if ... else, чтобы проверить ошибки вручную  
- Использовать только логирование ошибок без перехвата исключений  
- try ... finally для перехвата исключений  
- throw/raise для защиты кода от ошибок  
- try ... catch/except ... для обработки ошибок  

---

## Вопрос 7  
Когда стоит предпочесть интерфейс перед абстрактным классом?  

- Когда необходимо реализовать одинаковую бизнес-логику для всех наследников  
- Когда требуется объединить данные и методы от нескольких базовых классов  
- Когда требуется предоставить частичную реализацию методов в базовом классе  
- Когда требуется ограничить использование методов внутри одного класса  
- Когда нужно определить контракт без реализации для классов, не связанных общей иерархией  

---

## Вопрос 8  
У вас есть иерархия классов для работы с фигурами: базовый класс Figure и два его дочерних класса — Rectangle и Circle. Класс Rectangle имеет дополнительный метод get\_area(), который возвращает площадь прямоугольника.  

В языках со строгой типизацией каким образом можно использовать приведение типов для получения площади прямоугольника, используя метод get\_area()?  

- Создать объект класса Figure, передав в качестве аргумента объект класса Rectangle, и вызвать метод get\_area() на объекте класса Figure  
- Привести объект класса Figure к типу Rectangle и вызвать метод get\_area() на объекте класса Rectangle  
- Создать объект класса Rectangle, передав в качестве аргумента объект класса Figure, и вызвать метод get\_area() на объекте класса Rectangle  
- Приведение типов в данном случае невозможно  
- Привести объект класса Rectangle к типу Figure и вызвать метод get\_area() на объекте класса Figure  

---

## Вопрос 9  
Вы разрабатываете систему с возможностью обработки данных различных типов, используя один и тот же метод. Какой подход следует выбрать для достижения этой цели?  

- Применить абстрактные классы для создания объектов всех возможных типов данных  
- Создать отдельные классы для каждого типа данных с одинаковыми методами и общей логической структурой  
- Разделить логику на уровне метода, создав дополнительные условия, чтобы обрабатывать каждый тип данных по-своему  
- Использовать обобщенные классы, чтобы поддерживать полиморфизм при работе с разными типами данных  
- Использовать интерфейсы для унификации методов, работающих с данными  

---

## Вопрос 10  
У вас есть модули, которые зависят друг от друга: если вы меняете один модуль, вы должны внести изменения в зависимые модули.  

Какой термин используется для описания этой проблемы?  

- Проблема связанности  
- Проблема полиморфизма  
- Проблема иерархии модулей  
- Проблема модульности  
- Проблема сопряжения  

---

## Вопрос 11  
Какой механизм в объектно-ориентированном программировании позволяет создавать экземпляры класса, используя данные сигнатуры вызова, обеспечивая гибкость инициализации объектов при различных условиях?  

- Инстанцирование объекта с использованием перегруженных конструкторов  
- Наследуемая архитектура с множеством фабричных методов  
- Композиция и полиморфизм с измененными параметрами  
- Адаптивная инициализация через многоуровневую структуру конструктора  
- Динамическая диспетчеризация через множественные сигнатуры вызова  

---

## Вопрос 12  
Какой из антипаттернов может возникнуть при чрезмерном применении универсальных решений для всех задач?  

- Золотой молоток (Golden Hammer)  
- Циклические зависимости (Circular Dependency)  
- Временная связанность (Temporal Coupling)  
- Поток лавы (Lava Flow)  
- Избыточное использование синглтона (Singleton Overuse)  

---

## Вопрос 13  
Какое из утверждений верно?  

- Принцип абстракции относится к объектно-ориентированному программированию, а инкапсуляции – к процедурному  
- Абстракция может достигаться путем использования интерфейсов, а инкапсуляция – за счет модификаторов доступа  
- Абстракция – это конкретный механизм реализации принципа инкапсуляции  
- Абстракция и инкапсуляция – это синонимичные понятия  
- Переопределение метода – это прием реализации инкапсуляции, а виртуальные методы – прием реализации абстракции  

---

## Вопрос 14  
В процессе создания библиотеки ваша команда стремится обеспечить, чтобы некоторый участок кода выполнялся в любом случае – независимо от того, возникло ли исключение. Какой подход позволит реализовать это поведение?  

- Использовать конструкцию, в которой обработка ошибок завершается без выполнения финального кода  
- Внедрить метод, позволяющий игнорировать исключения и завершать выполнение без обработки  
- Применять структуру, которая гарантирует выполнение завершающего блока кода вне зависимости от наличия исключения  
- Осуществить механизм, который прерывает выполнение программы при возникновении исключения  
- Реализовать схему, при которой завершающий код вызывается только при наличии ошибки  

---

## Вопрос 15  
В какой из ситуаций ниже корректно применить абстрактные классы, а не интерфейсы?  

- Когда необходимо хранить общее состояние классов-наследников  
- Когда нужно создать разнородные по состоянию классы, но с общим действием (методом)  
- Во всех перечисленных выше случаях  
- Когда нужно использовать множественное наследование  
- Когда необходимо уменьшить связанность кода  

---

## Вопрос 16  
При разработке новой системы команда проектирует набор независимых компонентов, каждый из которых отвечает за отдельный тип поведения (например, полуправление, сервисная защита). Какой подход обеспечит гибкость реализации и соответствие принципам объектно-ориентированного проектирования?  

- Реализовать несколько отдельных интерфейсов, чтобы каждый класс мог реализовывать только нужные поведения  
- Объединить поведение в иерархии наследования через абстрактные классы  
- Использовать один абстрактный класс с реализацией всех вариантов поведения  
- Вынести общее поведение в статические методы и вызывать их из разных классов  
- Создать один интерфейс с методами для всех типов поведения  

---

## Вопрос 17  
В каком из приведенных ниже вариантов ответа присутствуют проблемы как связанности, так и связности, возникшие при создании классов и объектов в ООП?  

- Методы класса выполняют четкий набор понятных задач, а также изменение в классе автоматически изменяет дочерний класс  
- Класс зависит от данных, подгруженных через API, а компоненты системы жестко изолированы друг от друга  
- Родительский класс не влияет на дочерний, а методы первого определяются через методы второго  
- Методы и функции класса выполняют разнообразные задачи, а также связанность класса с дочерним не выстроена  
- Система содержит два класса, один из которых наследует изменения в другом, а родительский класс получает данные при вводе с клавиатуры  