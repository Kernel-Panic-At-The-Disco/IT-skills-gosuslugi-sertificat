# **OOP\_middle**

**Вопрос 1**

Какое из утверждений верно?

1. Объект это функция, класс значение, возвращаемое этой функцией  
2. Объект это шаблон, определяющий состояние и поведение классов, класс экземпляр объекта  
3. Класс это имя переменной, объект значение, которое присваивается этой переменной  
4. Класс это функция, объект значение, возвращаемое этой функцией  
5. Класс это шаблон, определяющий состояние и поведение объектов, объект экземпляр класса

**Вопрос 2**

Что из перечисленного — пример классического антипаттерна в объектно-ориентированном программировании?

1. Использование чрезмерно длинных имен методов в классах  
2. Использование большого количества вложенных циклов в коде  
3. Использование условных операторов со множественным ветвлением  
4. Использование класса с чрезмерно большим количеством методов, имеющих разное предназначение  
5. Использование индексации массива за пределами его диапазона

**Вопрос 3**

Какое из утверждений наиболее точно отражает связь между абстракцией и инкапсуляцией?

1. Абстракция всегда используется с полиморфизмом, инкапсуляция с наследованием  
2. Абстракция скрывает внутреннюю логику, инкапсуляция делает методы доступными  
3. Абстракция работает с приватными методами, инкапсуляция управляет публичными и статическими  
4. Абстракция фокусируется на классах, инкапсуляция на объектах и их методах  
5. Абстракция выделяет важные аспекты, инкапсуляция скрывает детали реализации

**Вопрос 4**

Что из перечисленного пример реализации статического полиморфизма?

1. Когда в классе есть несколько методов, имеющих одинаковое имя, но разное число параметров одного типа  
2. Когда необходимо создать утилитарный класс класс-помощник, содержащий статические переменные и статические методы  
3. Когда базовый класс имеет виртуальные методы, а дочерние классы переопределяют эти методы  
4. Когда необходимо, чтобы производные классы могли переопределять методы базового класса  
5. Во всех вышеперечисленных случаях

**Вопрос 5**

В каком из перечисленных случаев соблюден принцип единственной ответственности?

1. Класс OrderStatusControl содержит методы для управления статусом заказа  
2. Класс Order содержит методы для работы с оплатой, доставкой и управлением статусом заказа  
3. Класс Payment содержит методы для работы с оплатой заказа, а класс DeliveryOrderStatusControl — для работы с доставкой и управлением статусом заказа  
4. Класс Order содержит основной метод для работы с доставкой заказа и дополнительные методы для управления статусом заказа  
5. Класс PaymentDelivery содержит методы для работы с оплатой и доставкой заказа

**Вопрос 6**

Вы работаете в компании и создаёте программный код, который должен корректно обрабатывать ошибки и исключения. В ходе тестирования вы увидели, что программа может аварийно завершаться при возникновении ошибок. Какую конструкцию вы будете использовать для безопасного перехвата и обработки исключений?

1. Обернуть весь код в блок if ... else, чтобы проверить ошибки вручную  
2. Использовать только логирование ошибок без перехвата исключений  
3. try ... finally для перехвата исключений  
4. throw/raise для защиты кода от ошибок  
5. try ... catch/except ... для обработки ошибок

**Вопрос 7**

Когда стоит предпочесть интерфейс перед абстрактным классом?

1. Когда необходимо реализовать одинаковую бизнес-логику для всех наследников  
2. Когда требуется объединить данные и методы от нескольких базовых классов  
3. Когда требуется предоставить частичную реализацию методов в базовом классе  
4. Когда требуется ограничить использование методов внутри одного класса  
5. Когда нужно определить контракт без реализации для классов, не связанных общей иерархией

**Вопрос 8**

У вас есть иерархия классов для работы с фигурами: базовый класс Figure и два его дочерних класса — Rectangle и Circle. Класс Rectangle имеет дополнительный метод get\_area(), который возвращает площадь прямоугольника.

В языках со строгой типизацией каким образом можно использовать приведение типов для получения площади прямоугольника, используя метод get\_area()?

1. Создать объект класса Figure, передав в качестве аргумента объект класса Rectangle, и вызвать метод get\_area() на объекте класса Figure  
2. Привести объект класса Figure к типу Rectangle и вызвать метод get\_area() на объекте класса Rectangle  
3. Создать объект класса Rectangle, передав в качестве аргумента объект класса Figure, и вызвать метод get\_area() на объекте класса Rectangle  
4. Приведение типов в данном случае невозможно  
5. Привести объект класса Rectangle к типу Figure и вызвать метод get\_area() на объекте класса Figure

**Вопрос 9**

Вы разрабатываете систему с возможностью обработки данных различных типов, используя один и тот же метод. Какой подход следует выбрать для достижения этой цели?

1. Применить абстрактные классы для создания объектов всех возможных типов данных  
2. Создать отдельные классы для каждого типа данных с одинаковыми методами и общей логической структурой  
3. Разделить логику на уровне метода, создав дополнительные условия, чтобы обрабатывать каждый тип данных по-своему  
4. Использовать обобщенные классы, чтобы поддерживать полиморфизм при работе с разными типами данных  
5. Использовать интерфейсы для унификации методов, работающих с данными

**Вопрос 10**

У вас есть модули, которые зависят друг от друга: если вы меняете один модуль, вы должны внести изменения в зависимые модули.

Какой термин используется для описания этой проблемы?

1. Проблема связанности  
2. Проблема полиморфизма  
3. Проблема иерархии модулей  
4. Проблема модульности  
5. Проблема сопряжения