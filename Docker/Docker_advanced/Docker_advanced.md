# Docker_advanced

## Вопрос 1  
Вы разрабатываете CI/CD пайплайн для сборки и публикации образов Docker. Вы заметили, что кэш для сборки теряется при переходе между этапами пайплайна, из-за чего каждый новый этап заново пересобирает неизмененные слои.  
Выберите верное решение проблемы.  

- Передача флага --no-cache на каждом этапе пайплайна предотвратит потерю кэша, так как сборка будет полностью обновляться на каждом этапе  
- Использование внешнего централизованного хранилища кэша позволит сохранить и повторно использовать кэш между этапами пайплайна  
- Регулярное обновление базового образа поможет устранить проблемы с потерей кэша при сборке новых слоев  
- Увеличение количества шагов в Dockerfile для разделения задач повысит производительность и сохранит кэш между этапами.  
- Уменьшение количества шагов сборки ускорит процесс и минимизирует риск потери кэша между этапами  

---

## Вопрос 2  
В вашем Dockerfile используется инструкция ADD для копирования файлов и извлечения архива:  
```dockerfile
FROM nginx:latest  
ADD /app.tar.gz /usr/share/nginx/html  
ADD /config/nginx.conf /etc/nginx/nginx.conf  
CMD ["nginx", "-g", "daemon off;"]  
```
Вы заметили, что сборка образа занимает больше времени, чем ожидалось, а размер образа увеличивается из-за ненужных файлов. Вы внесли изменения.  
После изменений:  
1. Сборка образа стала занимать меньше времени.  
2. Размер образа уменьшился, так как больше нет ненужных файлов из архива.  
Какие изменения были внесены?  

- Установка минимальной версии Nginx для уменьшения размера базового образа  
- Использование ADD для всех операций, так как это универсальная инструкция  
- Перемещение CMD перед инструкцией ADD для ускорения сборки  
- Уменьшение размера образа, удаление архива после его извлечения в Dockerfile  
- Замена ADD на COPY для копирования файлов и распаковка архива заранее  

---

## Вопрос 3  
Вы разрабатываете приложение, состоящее из трех сервисов: frontend, backend и database. В Docker Compose файле для каждого сервиса назначена своя собственная сеть, а не общая. После запуска через Docker Compose frontend не может подключиться к backend, и в логах frontend появляются ошибки соединения.  
Почему это происходит?  

- Отсутствие настройки volumes вызывает потерю данных, но не влияет на сетевое взаимодействие между контейнерами  
- Bridge-сеть в Docker Compose не поддерживает DNS резолвинг, что делает невозможным взаимодействие сервисов  
- Сервисы запущены в отдельных сетевых пространствах, что препятствует их взаимодействию друг с другом  
- Отсутствие секции depends_on приводит к случайному порядку запуска контейнеров, что блокирует их сетевое взаимодействие  
- Отсутствие healthcheck приводит к попытке подключения frontend к backend до полной готовности последних  

---

## Вопрос 4  
Ваше приложение использует два контейнера: API и Redis. Они должны быть изолированы от других контейнеров в системе, но при этом поддерживать прямое взаимодействие между собой. Вы настроили отдельную сеть, но контейнеры не могут подключиться друг к другу.  
Почему возникала проблема?  

- Поскольку контейнеры не подключены к одной и той же сети, они не могут взаимодействовать друг с другом  
- Один из контейнеров использует параметр --network=host, нарушая изоляцию сети и взаимодействие с другими контейнерами  
- В секции networks отсутствует явное указание имени сети, что мешает контейнерам подключаться к одной сети  
- Для контейнеров не настроены алиасы в сети, что мешает их взаимодействию через DNS  
- Контейнеры подключены к разным bridge-сетям, что мешает их взаимодействию  

---

## Вопрос 5  
На продакшн-сервере контейнер web-analytics начал демонстрировать нестабильную работу, в недавнее время обновления контейнера не производилось: увеличились задержки в ответах приложения, CPU загружено на 100%. Логи не содержат ошибок, но работа сервиса ощутимо замедлена. При этом:  
* Контейнер нельзя остановить для диагностики.  
* Интерактивный доступ внутрь контейнера запрещен по политике безопасности.  
Какова наиболее вероятная причина проблем и правильный подход к диагностике?  

- Плохо написанный код вызывает высокую нагрузку на CPU, для ликвидации проблемы требуется переписать код  
- Операционная система хоста стала источником проблемы сильного роста задержек, необходимо немедленно перезагрузить сервер и перезапустить все контейнеры заново  
- Увеличение задержек в ответах связаны с неправильной настройкой сети контейнера, требуется переподключение к виртуальной сети через docker network connect  
- Высокая нагрузка вызвана "зависшими" процессами внутри контейнера, их надо выявить с помощью анализа активных процессов через docker top и мониторинга ресурсов через docker stats  
- Рост задержек происходит из-за того, что контейнер исчерпал лимиты открытых файловых дескрипторов, необходимо увеличить параметр ulimit через перезапуск контейнера  

---

## Вопрос 6  
На вашем сервере обнаружены контейнеры, которые:  
* Имеют доступ ко всем устройствам хоста.  
* Могут выполнять любые системные вызовы.  
* Работают в одной сети с другими контейнерами без ограничений.  
Это повышает риски безопасности контейнерной платформы. При этом сами контейнеры работают стабильно и без сбоев.  
Какова главная причина уязвимости в изоляции этих контейнеров?  

- Контейнеры используют приватные пространства имен, но неправильно настроены ограничения cgroups на ресурсы  
- Контейнеры были ограничены по CPU и памяти, но оставлены без настройки capabilities  
- Контейнеры развернуты в режиме read-only, что снижает уровень угроз со стороны приложений  
- Контейнеры используют bridge-сеть с закрытыми портами, но доступ к устройствам хоста остался открыт  
- Контейнеры запущены с настройкой seccomp-профиля, что позволяет получить доступ ко всем хостовым устройствам  

---

## Вопрос 7  
При работе с приложением, использующим Docker-контейнеры, вы заметили следующие факты:  
1. Логи контейнеров не сохраняются на хостовой системе  
2. Конфликты записи между несколькими контейнерами, использующими общий том  
3. Появление дублирующихся или конфликтующих файлов при восстановлении из резервной копии  
Какой аспект настройки данных в Docker мог вызвать эти проблемы?  

- Отсутствие ротации логов для предотвращения переполнения томов  
- Отсутствие режима read/write разделения между контейнерами  
- Использование анонимных (безымянных) томов без явного монтирования на хостовую систему  
- Использование тома без предварительного монтирования на хост  
- Неправильная структура хранения данных внутри тома  

---

## Вопрос 8  
В кластере Docker с несколькими контейнерами возникли проблемы с производительностью приложения, которые проявляются в виде периодического замедления работы контейнеров.  
Проблема не имеет явных ошибок в логах, но наблюдается ухудшение работы, связанное с повышенным использованием CPU, памяти или сетевого трафика.  
Какой из факторов стал ключевым в затруднении диагностики?  

- Использование разных версий образов в production и staging  
- Слишком медленно пишутся логи, из-за чего при нагрузке они не успевают создаваться  
- Неправильно выставленные лимиты ресурсов через Docker Compose  
- Наличие большого количества временных контейнеров (dangling containers)  
- Отсутствие систематического сбора метрик о потреблении ресурсов (CPU, память, сеть)  

---

## Вопрос 9  
Вы разрабатываете CI/CD пайплайн для проекта с использованием Docker. Docker используется для создания и тестирования образов, а также для автоматической установки зависимостей.  
Какие преимущества вам это даст?  

- Создает автоматически резервные копии данных на каждом этапе пайплайна  
- Автоматически добавит все необходимые зависимости для тестов в образ  
- Даст возможность сборки образов, а тесты будут выполняться на хост-системе  
- Позволит запускать тесты в изолированных средах, идентичных боевым  
- Исключит необходимость запуска тестов, так как контейнеры уже проверены  

---

## Вопрос 10  
Как сканеры уязвимостей помогают в CI/CD?  

- Интегрируются в пайплайн и могут блокировать публикацию образов  
- Обнаруживают только уязвимости, связанные с сетевыми атаками  
- Ускоряют процесс деплоя, уменьшая количество проверок  
- Автоматически исправляют уязвимости  
- Интегрируются в CI/CD для мониторинга безопасности  

---

## Вопрос 11  
В production-среде с множеством Docker-контейнеров были обнаружены следующие проблемы:  
А. Несколько контейнеров начали использовать неожиданно высокий объем сетевого трафика, что привело к перегрузке сети.  
В. Логи показывают, что некоторые контейнеры пытаются получить доступ к ресурсам других контейнеров, к которым у них не должно быть доступа.  
С. Один из контейнеров начал выполнять команды, которые не были предусмотрены его функциональностью.  
В чем причина проблемы?  

- Использование изолированной bridge-сети с настроенными правилами firewall, что позволяет контролировать сетевой трафик контейнеров  
- Отсутствие мониторинга сетевой активности контейнеров и использования инструментов для анализа трафика  
- Запуск контейнеров с параметром --privileged, что дает им полный доступ к хосту и другим контейнерам  
- Использование пользовательских сетей Docker, но без ограничения доступа к критическим системным ресурсам хоста  
- Использование устаревших образов с известными уязвимостями, которые могут быть эксплуатированы злоумышленниками  

---

## Вопрос 12  
Как установка ограничения памяти для контейнера может предотвращать ошибки Out of Memory?  

- Автоматически перераспределяет ресурсы памяти между всеми контейнерами  
- Позволяет выбранному контейнеру использовать swap-память без сильных ограничений  
- Не дает перегружать хост, заставляя приложение эффективно использовать доступную память  
- Уменьшает нагрузку на процессор контейнера, снижает у него потребление памяти  
- Оптимизирует код приложения для более эффективного использования памяти  

---

## Вопрос 13  
Приложение в Docker обрабатывает файлы большого объема, но при этом обработка выполняется медленно. Логи показывают, что файловая система контейнера ограничивает скорость чтения и записи данных. Это влияет на время выполнения операций и производительность всего приложения.  
Что поможет оптимизировать обработку данных?  

- Настроить репликацию контейнера для распределения нагрузки  
- Ограничить доступ контейнера к внешним ресурсам  
- Удалить неиспользуемые файлы из контейнера  
- Использовать тома Docker для ускорения работы с файлами  
- Использовать новую bridge-сеть вместо стандартной сети Docker  

---

## Вопрос 14  
Какое преимущество использования секции secrets перед передачей данных через общие тома (volumes)?  

- Docker управляет жизненным циклом секретов и ограничивает их доступность  
- Секреты можно изменять динамически без перезапуска сервисов  
- Секреты автоматически кэшируются для ускорения запуска контейнеров  
- Тома требуют настройки сетевых политик для каждого контейнера  
- Тома не поддерживают права доступа только для чтения  

---

## Вопрос 15  
Вы настраиваете Docker Swarm для приложения, которое использует несколько секретов, таких как ключи API и пароли. После развертывания несколько сервисов не могут получить доступ к своим секретам, а логи указывают на отсутствие необходимых данных. Сервисы продолжают работать нестабильно, что приводит к сбоям в приложении и возможным нарушениям безопасности.  
Как правильно настроить доступ к секретам, чтобы устранить затруднение?  

- Добавить секреты в сам файл Docker Compose  
- Использовать общий том для передачи секретов между контейнерами  
- Настроить автоматическую синхронизацию секретов через общий реестр  
- Привязать секреты к конкретным сервисам, которые их используют  
- Сохранить секреты в переменных окружения для каждого сервиса  

## Вопрос 16  
Вы заметили, что при обновлении зависимостей приложения кэш для шагов, связанных с их установкой, теряется, что значительно увеличивает время сборки Docker-образа.  
Выберите верное решение проблемы.  

- Увеличение времени хранения кэша на CI/CD-сервере автоматически сохранит слои зависимости и ускорит сборку  
- Регулярное удаление кэша с помощью команды docker system prune уменьшит время сборки за счет очистки устаревших слоев  
- Разделение зависимостей и файлов приложения в многоступенчатой сборке позволит сохранить кэш и ускорить установку  
- Добавление всех файлов приложения перед установкой зависимостей в Dockerfile поможет избежать потери кэша и ускорить установку  
- Перемещение инструкций по установке зависимостей в конец Dockerfile поможет предотвратить потерю кэша и ускорить сборку  

---

## Вопрос 17  
Вы используете многоступенчатую сборку для создания контейнера:  
```dockerfile
FROM golang:1.26 AS builder
WORKDIR /src
COPY . .
RUN go build -o /app main.go
FROM alpine:3.18
WORKDIR /app
COPY --from=builder /app /app
CMD ["/app"]
```

При анализе вы заметили, что финальный образ содержит ненужные зависимости из базового образа alpine, что увеличивает его размер. Кроме того, сборка приложения занимает больше времени, чем ожидается.
Почему использование многоступенчатой сборки и команды COPY --from=builder не привело к ожидаемому результату?

- Установка минимальных зависимостей в образе alpine и их удаление после сборки не решает проблему с лишними зависимостями, которые все равно остаются в финальном образе
- Использование базового образа scratch вместо alpine исключает все лишние зависимости и уменьшает размер образа
- Добавление большего количества инструкций в этап builder не влияет на размер образа и не устраняет лишние зависимости
- Исключение зависимости go build в builder не уменьшает размер образа и не устраняет проблему с избыточными зависимостями
- Перемещение инструкций из builder в alpine приведет к увеличению размера образа и не решит проблему с зависимостями

---

## Вопрос 18

Вы настраиваете Docker Compose файл для автоматической загрузки образов из приватного реестра. После развертывания сервисов вы замечаете, что возникает ошибка аутентификации, из-за которой образы не могут быть загружены. Вы проверяете настройки секции services и networks, но не находите явных ошибок.
В чем причина?

- Использование локального образа вместо удаленного образа
- Настройки секции depends_on указаны с ошибкой
- Отсутствие выполнения docker login перед развертыванием
- Неправильная конфигурация секции networks
- Секция environment неверно настроена для сервиса database

---

## Вопрос 19

Ваше приложение работает с контейнерами, использующими тома Docker для временных файлов. В логах вы заметили следующее:

Некоторые контейнеры теряют доступ к томам после перезапуска.
Периодически появляются сообщения об ошибках доступа к файлам.
При сборке новых контейнеров старые временные файлы остаются в томах и приводят к увеличению их размера.

Что могло стать причиной этой ситуации?

- Несовместимость версий Docker CLI с настроенной конфигурацией томов
- Использование локальных томов вместо временных томов для временных данных
- Отсутствие автоматической очистки содержимого тома при завершении работы контейнера
- Контейнеры используют одни и те же тома, что приводит к конфликтам при создании/изменении файлов
- Использование одного тома для временных и постоянных данных

---

## Вопрос 20
Что безопаснее: использование инструкции USER в Dockerfile или параметра -u <user> при запуске контейнера?

- USER в Dockerfile, так как это обеспечивает безопасность на этапе сборки и предотвращает запуск контейнера от root
- USER в Dockerfile, так как это упрощает управление контейнерами и снижает вероятность ошибок
- -u <user> при запуске, так как это повышает производительность контейнера
- -u <user> при запуске, так как это позволяет гибко менять пользователя без изменения Dockerfile
- USER в Dockerfile, так как это позволяет избежать необходимости указывать пользователя при каждом запуске

---

## Вопрос 21
На сервере с 12 Docker-контейнерами вы заметили следующие аномалии:
1. Один контейнер постоянно увеличивает использование дискового пространства, хотя объем данных не изменяется.
2. Время отклика этого контейнера при запросах выросло в 2 раза за последние сутки.
3. В логах нескольких других контейнеров начали появляться ошибки записи данных, связанные с переполнением ресурсов.
В чем причина аномалий?

- Отсутствие мониторинга взаимодействия между контейнерами в пользовательской сети, что приводит к взаимному влиянию на производительность
- Неправильная настройка параметра --memory, что позволяет контейнеру использовать больше памяти, чем допустимо, вызывая ошибки записи
- Использование Docker Volumes без регулярной очистки устаревших данных, что приводит к накоплению ненужных файлов
- Отсутствие настройки --log-opt max-size для ограничения размера логов контейнеров, что приводит к росту дискового пространства и сбоям
- Настройка контейнера на постоянное создание новых слоев файловой системы вместо их сжатия, что увеличивает объем данных

---

## Вопрос 22
Почему overlay-сеть в Docker лучше подходит для связи контейнеров на разных хостах?

- Оптимизирована для связи контейнеров между разными хостами, снижая задержки
- Автоматически масштабирует все сетевые ресурсы по мере возрастания нагрузки
- Позволяет контейнерам использовать IP-адреса хоста, сильно ускоряя к ним доступ
- Обеспечивает полную изоляцию контейнеров, блокируя любой внешний трафик
- Использует частичное сжатие трафика, за счет чего уменьшает нагрузку на сеть

---

## Вопрос 23
Ваше приложение в Docker работает стабильно, но потребление дискового пространства растет из-за большого количества временных файлов, которые не удаляются автоматически. В результате хранилище хостовой системы быстро заполняется, создавая риск остановки работы приложения. Вы хотите автоматизировать процесс очистки временных файлов, чтобы избежать их накопления.
Как это сделать, не нарушая работу приложения?

- Удалить временные файлы вручную после каждого запуска контейнера
- Настроить периодическую очистку томов Docker
- Переместить временные файлы в удаленное хранилище
- Использовать cron-задачу для удаления временных файлов
- Добавить лимиты на использование дискового пространства для контейнера

---

## Вопрос 24
Для чего используют монтирование секретов в контейнер с правами только по чтению?

- Чтобы обеспечить совместимость во время выполнения с legacy-приложениями
- Чтобы автоматически архивировать все секреты после окончания использования
- Чтобы уменьшить объем памяти, занимаемый конкретным контейнером
- Чтобы скрыть секреты от других процессов, запущенных на данном хосте
- Чтобы запретить изменение секретов в процессе выполнения контейнера