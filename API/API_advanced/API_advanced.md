# API

## Вопрос 1  
В системе обработки медицинских данных требуется:  
1. Поддержка транзакционности операций  
2. Гарантированная доставка сообщений  
3. Соответствие HIPAA требованиям безопасности  
4. Интеграция с legacy-системами на IBM Mainframe.  
Выберите верное обоснование. Какой протокол предпочтительнее: REST или SOAP?  

- SOAP, так как WS-AtomicTransaction и WS-ReliableMessaging обеспечивают требования, а WS-Security с XML-Encryption соответствует HIPAA  
- REST с gRPC, так как HTTP/2 снижает задержки, а interceptors можно использовать для имитации транзакций  
- REST, потому что HIPAA допускает защиту данных на уровне TLS, и можно избежать сложности WS-Security  
- REST, так как OAuth 2.0 и JWT позволяют реализовать гибкую авторизацию, соответствующую требованиям HIPAA  
- SOAP, потому что WSDL позволяет типизированную интеграцию с IBM Mainframe-системами  

---

## Вопрос 2  
Вы документируете RESTful API с помощью Swagger и хотите проверить, как ваше приложение взаимодействует с различными эндпоинтами API. Документация должна включать интерактивное тестирование всех эндпоинтов. Вы хотите предоставить разработчикам возможность тестировать API без использования сторонних инструментов, таких как Postman.  
Какую последовательность действий следует выполнить в Swagger, чтобы предоставить интерактивную документацию с возможностью тестирования эндпоинтов?  

- Настроить Mock-сервер для тестирования всех эндпоинтов API  
- Добавить примеры запросов вручную в виде текстового описания к каждому эндпоинту  
- Использовать вкладку "Authorization" в Swagger для генерации токенов доступа к API  
- Настроить спецификацию OpenAPI и включить Swagger UI для автоматического отображения эндпоинтов и их тестирования  
- Создать коллекцию запросов в Postman и экспортировать их для тестирования  

---

## Вопрос 3  
При разработке защищенного API вы рассматриваете использование Basic Authentication или OAuth 2.0.  
Какое ключевое преимущество OAuth 2.0 будет для вас самым значимым по сравнению с Basic Authentication в контексте безопасности и управления доступом?  

- Упрощает настройку без необходимости дополнительных серверных модулей контроля доступа  
- Предоставляет ограниченный access к ресурсам через токены без передачи пароля пользователя  
- Автоматически обновляет токены при истечении их срока действия  
- Облегчает внедрение многофакторной аутентификации  
- Использует бессменные токены вместо постоянной передачи учётных данных  

---

## Вопрос 4  
В вашем API используется JWT для аутентификации. Однако пользователи столкнулись с ошибкой, после того как токен был скомпрометирован. Пользователи не могли отозвать токен, что привело к неконтролируемому доступу к ресурсам до истечения срока его действия.  
Выберите ответ, который верно описывает свойства метода JWT, которые приводят к такой ошибке.  

- JWT требуют сложного алгоритма проверки подписи, который может замедлять работу самой системы  
- Токены являются автономными и содержат всю информацию о пользователе, что делает их неподконтрольными серверу  
- JWT поддерживают обновление токенов при каждом запросе, повышая безопасность  
- Токены имеют очень короткий срок жизни, что сильно ограничивает вероятность их компрометации  
- JWT зависят от внешнего сервиса для хранения данных о сессиях  

---

## Вопрос 5  
Клиент отправляет запрос, в котором одновременно: превышает допустимый лимит запросов (rate limit), и обращается к защищённому ресурсу, не имея нужных прав доступа. Обе ошибки требуют отклонения запроса. Однако сервер должен выбрать одну и вернуть соответствующий код.  
Почему в этой ситуации предпочтительно вернуть код 403, а не 429?  

- По причине того, что 429 должен возвращаться первым, так как клиент уже нарушил лимит и это не влияет на 403  
- Так как 403 используется только для POST-запросов, тогда как 429 — для любых типов запросов  
- Так как 429 информирует о техническом ограничении, которое важнее ошибок авторизации  
- Потому что 403 отражает проблеме авторизации, которая делает запрос невозможным вне зависимости от частоты обращений  
- 403 приоритетнее, так как код 429 указывает на избыточную нагрузку, которая может блокировать даже корректно авторизованные запросы  

---

## Вопрос 6  
Вы разрабатываете API для управления задачами. При попытке удалить задачу методом DELETE некоторые клиенты получают код ошибки 404 Not Found, хотя задача существует. Необходимо предотвратить ошибку и корректно удалить ресурс, обеспечивая точное указание причины ошибки, если она возникает.  
Какие действия помогут устранить проблему?  

- Проверить наличие задачи перед вызовом метода DELETE, возвращая 404 только если задача действительно не существует  
- Изменить метод DELETE на PUT, чтобы обновить ресурс  
- Установить ограничение на количество удаляемых записей в одном запросе  
- Переключиться на метод PATCH для пометки задачи как удаленной, вместо ее непосредственного удаления  
- Указывать JSON как формат передачи данных в заголовке Content-Type  

---

## Вопрос 7  
Во время обновления статуса заказа методом PATCH некоторые клиенты столкнулись с неожиданными потерями данных. Вам нужно выявить паттерн ошибок и определить, в каких ситуациях этот метод может привести к потере данных.  
Какое свойство метода PATCH может привести к потере данных при отправке пустых или отсутствующих значений в запросе? PATCH...  

- Всегда проверяет целостность всех данных перед каждой обработкой запроса  
- Обрабатывает пустые значения в запросе, заменяя текущие значения на пустые  
- Требует строгого соответствия типов данных, блокируя доступ  
- Создает копии не всех данных полностью перед новым частичным обновлением  
- Автоматически создает новый ресурс при отсутствии существующего ресурса  

---

## Вопрос 8  
Ваш API поддерживает массовую загрузку больших объемов клиентских данных. Клиенты жалуются, что при увеличении объемов записей загрузка становится слишком медленной и начинает негативно влиять на общий отклик системы. Необходимо оптимизировать процесс массовой загрузки, учитывая следующие факторы:  
1. Высокая конкурентность (множество клиентов могут одновременно загружать данные)  
2. Требование гарантировать целостность и корректность загрузки (частичная загрузка не должна сломать систему)  
3. Необходимость уменьшить общее время отклика и повысить масштабируемость  
4. Сохранить устойчивость системы: даже если одна из партий данных содержит ошибку, процесс не должен приводить к сбою всего сервиса  
Какой подход вы примените, чтобы обеспечить стабильную и эффективную массовую загрузку данных, учитывая все факторы и риск перегрузки системы?  

- Применить кэширование для часто запрашиваемых данных (например, Redis), чтобы ускорить повторные операции чтения  
- Использовать серверное сжатие данных для уменьшения объемов передаваемой информации  
- Реализовать стратегию частичных запросов с использованием пагинации или чанков, позволяющую обрабатывать данные порциями и поддерживать согласованность  
- Уменьшить размер данных, исключив необязательные поля из ответа и запроса, чтобы сохранить нагрузку  
- Переключиться на отправку данных в реальном времени через WebSocket для мгновенного отклика при загрузке крупных пакетов  

---

## Вопрос 9  
Вы используете WebSocket для передачи данных о курсах валют в реальном времени. Однако частые обновления курсов создают высокую нагрузку на сервер и пропускную способность сети. Вам нужно уменьшить количество передаваемых сообщений без потери важной информации.  
Какой подход оптимизирует передачу данных по WebSocket, снижая нагрузку, но сохраняя важную информацию?  

- Ограничить частоту отправки обновлений с помощью специальных механизмов троттлинга  
- Использовать REST API вместо WebSocket для передачи данных сообщений без потери  
- Сжимать сообщения с помощью gzip перед отправкой сообщений с важной информацией  
- Переключиться для оптимизации на SSE для однонаправленной передачи данных  
- Отправлять только изменения данных (диффы) вместо полного набора значений  

---

## Вопрос 10  
Вы планируете опубликовать свое API для внешних разработчиков и хотите предоставить актуальную документацию, которая автоматически обновляется при изменениях в коде. Список факторов:  
1. Использование аннотаций кода для генерации документации  
2. Возможность преобразования спецификации OpenAPI в различные языки программирования  
3. Генерация пользовательского интерфейса (UI), который отображает текущее состояние API  
Какие из перечисленных факторов связаны с поддержкой автоматического обновления документации в OpenAPI?  

- Только фактор 2  
- Все три фактора  
- Только фактор 1  
- Только фактор 3  
- Факторы 1 и 3  

---

## Вопрос 11  
Вы предлагаете API для нескольких внутренних подразделений, каждое из которых использует разные системы. Одни требуют XML, другие — JSON. Возникла идея поддерживать отдельные эндпоинты для каждого формата, чтобы минимизировать риск конфликтов при обновлениях. Дополнительно в компании принято соглашение, что URL, заканчивающийся на .json или .xml, поможет департаментам четко отличать эндпоинты.  
Что нужно сделать, чтобы отделить формат данных уже на уровне URL и избежать необходимости в дополнительных заголовках?  

- Реализовать два эндпоинта, например /api/v2/users.json и /api/v2/users.xml, возвращая разные форматы  
- Принимать любой запрос и всегда возвращать оба формата, вложенные в один ответ  
- Автоматически возвращать XML, если клиентская ОС Windows, и JSON — если Linux  
- Хранить в базе два разных набора данных и переключаться между ними в зависимости от названия эндпоинта  
- Настроить CDN, который разделит .json файлы из одного хранилища, а .xml — из другого  

---

## Вопрос 12  
Вы хотите добавить информацию о ролях и правах пользователя в JWT-токен, чтобы использовать его для авторизации.  
Каким образом лучше всего включить эти данные в JWT, чтобы обеспечить их безопасность и актуальность?  

- Передавать роли и права пользователя в виде зашифрованных данных в теле ответа на каждый запрос  
- Добавить роли и права в заголовок токена, чтобы они всегда были видны при передаче данных  
- Включить информацию о ролях в полезную нагрузку токена и подписывать JWT с использованием безопасного алгоритма  
- Включить роли в URL-параметры каждого запроса, чтобы не использовать сложные методы подписи  
- Хранить права и роли на сервере, а в JWT-токен добавлять только уникальный идентификатор пользователя  

---

## Вопрос 13  
Вы разрабатываете высоконагруженное GraphQL API для приложения обмена сообщениями, где требуются мгновенные уведомления о новых сообщениях и статусе пользователей (онлайн/оффлайн). При этом часть клиентов (например, мобильные) ограничены в ресурсах и не могут часто опрашивать сервер (polling). Вы также хотите избежать лишней нагрузки на инфраструктуру, так как постоянные запросы Query увеличивают нагрузку. Нужно обеспечить реальное время (real-time) получения данных, сохранив при этом гибкость и масштабируемость сервиса.  
Какой из методов GraphQL оптимально применить для организации двунаправленной связи между сервером и клиентом, позволяющей передавать обновления по мере их появления?  

- Mutation в GraphQL  
- Subscription в GraphQL  
- Resolver в GraphQL  
- Query в GraphQL  
- Directive в GraphQL  

---

## Вопрос 14  
Ваш API обслуживает тысячи клиентов, и вы замечаете, что несколько из них отправляют аномально большое количество запросов в короткий промежуток времени. Это негативно влияет на производительность и приводит к сбоям в обработке запросов других клиентов. Вам нужно внедрить гибкое ограничение нагрузки через API Gateway, которое будет учитывать:  
1. Идентификацию клиентов (например, через токены)  
2. Дифференциацию правил (например, VIP-клиенты могут отправлять больше запросов)  
3. Мгновенную блокировку клиентов, нарушающих лимиты  
Как настроить API Gateway для решения этой задачи?  

- Настроить IP-блокировку для всех клиентов, превышающих лимиты  
- Добавить правило для обработки VIP-клиентов через кастомные политики API Gateway  
- Ограничить доступ к API для всех клиентов, кроме заранее определенных групп  
- Сформировать функцию rate-limiting с динамическими лимитами, привязанными к идентификаторам клиентов  
- Использовать кэширование для временного хранения запросов и уменьшения нагрузки  

---

## Вопрос 15  
Ваш API поддерживает четыре основные версии, каждая из которых реализует схожую функциональность с незначительными изменениями. Например:  
1. Версии 1 и 2 возвращают данные в разных форматах (JSON, XML)  
2. Версия 3 добавляет параметры для фильтрации, которые отсутствуют в других версиях  
3. Версия 4 поддерживает агрегированные данные для определенных отчетов  
4. Разработчики вынуждены поддерживать эти версии, внося изменения вручную в каждую из них. Это приводит к ошибкам, задержкам и дублированию кода. Также пользователи жалуются на сложность работы с API, так как документация недостаточно детализирована для каждой версии.  
Какой подход поможет уменьшить сложность кода, сохранить обратную совместимость и упростить обновления API, сохраняя обратную совместимость для существующих клиентов?  

- Добавить возможность передачи всех параметров через единый объект, чтобы сократить количество дублирующего кода  
- Внедрить API Gateway для управления запросами к разным версиям  
- Удалить старые версии API и оставить только последнюю, предложив клиентам обновиться  
- Реализовать конвертер форматов данных на уровне клиента, чтобы уменьшить число поддерживаемых версий  
- Объединить ключевые функции из всех версий в одну универсальную реализацию, сохранив совместимость через параметры  

---

## Вопрос 16  
Какое ключевое преимущество REST делает его оптимальным для масштабируемых веб-сервисов?  

- REST использует SOAP для обмена сообщениями между клиентом и сервером, дополняя его возможности  
- REST основан на использовании статических IP-адресов для всех ресурсов и поэтому он быстрее  
- REST обеспечивает встроенную поддержку транзакций и надежной доставки сообщений между клиентами и сервером  
- REST требует использования сложных XML-сообщений для взаимодействия, а SOAP для обмена  
- REST опирается на стандарты HTTP и методы GET, POST, PUT, DELETE, что упрощает интеграцию и масштабирование  

---

## Вопрос 17  
Ваше приложение должно взаимодействовать с RESTful API, и вы хотите протестировать корректность обработки POST-запросов. Вам необходимо проверить, что сервер правильно возвращает ошибки при некорректно сформированных данных в теле запроса. Тело запроса должно содержать JSON-объект с обязательными параметрами. Тестирование должно включать автоматическую проверку содержимого ответов на запросы.  
Какую последовательность действий следует выполнить в Postman, чтобы автоматически проверить, что сервер возвращает ошибки при некорректных данных в запросе?  

- Создать новый Mock-сервер, отправить на него тестовые запросы и проверить, что возвращаются ошибки  
- Сформировать коллекцию запросов и использовать "Monitor" для анализа ответа API  
- Настроить тело запроса во вкладке "Body", выбрать формат JSON, отправить запрос и в "Tests" добавить скрипт проверки статуса ответа и текста ошибки  
- Открыть вкладку "Authorization" и ввести токен доступа для отправки запросов  
- Включить логирование запросов в Postman и вручную анализировать содержимое ошибок  

---

## Вопрос 18  
Вы разрабатываете API для веб-приложения, где требуется обеспечить высокую безопасность передачи данных. Как применение JWT повышает безопасность передачи данных между клиентом и сервером?  

- Шифрует полезную нагрузку токена для предотвращения перехвата  
- Предоставляет встроенную защиту от повторных запросов за счёт проверки временной метки  
- Автоматически отзывает устаревшие токены при их замене  
- Содержит цифровую подпись, позволяющую убедиться в целостности и подлинности токена  
- Требует обязательную двухфакторную аутентификацию для каждого запроса  

---

## Вопрос 19  
Ваш API использует надстройку OpenID Connect над OAuth 2.0, выступающая в качестве протокола аутентификации для авторизации пользователей. Во время тестирования вы заметили, что повторные запросы авторизации от одного и того же пользователя не создают новую сессию, а продолжают использовать уже существующую. Это положительно повлияло на производительность и на предотвращение возможных конфликтов данных.  
В чем причины таких изменений использования OpenID Connect?  

- Не создает новые токены, если пользователь уже имеет активный токен для текущей сессии  
- Автоматически завершает предыдущую сессию при получении нового запроса, чтобы избежать конфликта  
- Использует статические токены, которые не поддерживают привязку к сессиям  
- Требует ручной синхронизации сессий между запросами для предотвращения дублирования  
- Ассоциирует токены с текущей сессией, что предотвращает их дублирование и создание новых сессий  

---

## Вопрос 20  
Ваш API поддерживает регистрацию новых пользователей. Клиент отправляет запрос на регистрацию, который проходит базовую проверку синтаксиса, но содержит данные, не соответствующие правилам валидации (например, неверный формат email или слабый пароль). Сервер должен уведомить клиента о проблеме.  
Почему сервер должен использовать код 422 для этой ситуации?  

- Несоответствие данных требованиям требует от клиента корректировки, а не изменения структуры запроса  
- Он ясно указывает, что данные запроса не соответствуют требованиям, даже если синтаксис корректен  
- Он выделяет ошибки валидации данных, делая их понятными для клиента  
- Он информирует клиента о необходимости пересмотреть содержимое данных для успешной обработки запроса  
- Сервер не может обработать запрос из-за неверных данных, а не из-за ошибок в синтаксисе  

---

## Вопрос 21  
Ваш API позволяет пользователям изменять данные своих профилей. Однако администраторы могут обновлять данные любого пользователя. Требуется ограничить возможности изменения данных для обычных пользователей, чтобы они могли редактировать только свои профили, а администраторы — профили других пользователей. Решение должно быть масштабируемым, безопасным и эффективным для распределенной системы.  
Какие действия вы предпримете для реализации разграничения доступа?  

- Разграничить операции на уровне API, добавить проверку прав доступа перед выполнением запросов  
- Реализовать фильтрацию запросов по IP-адресу клиента для определения уровня доступа  
- Отключить возможность обновления данных через PATCH для всех пользователей, кроме администраторов  
- Запретить операции обновления для всех пользователей, кроме администраторов, при отсутствии дополнительных атрибутов в запросе  
- Использовать уникальные заголовки HTTP, чтобы указать роли пользователей при каждом запросе  

---

## Вопрос 22  
Некоторые пользователи вашего API получают некорректные или устаревшие данные при запросах методом GET. Требуется выявить закономерности, которые приводят к этой проблеме, и определить возможные причины получения неверных данных.  
Что может вызывать в GET во время настройки сервера возвращение устаревших данных?  

- Использование уникального URL для каждого GET запроса  
- Кэширование ответов, которое не обновляется при изменении данных  
- Превышение лимита запросов, блокирующее обновления данных  
- Ошибка при отправке заголовка Content-Type  
- Применение метода GET только для авторизованных пользователей  

---

## Вопрос 23  
Ваш API позволяет удалить заказы клиентов. При удалении заказа дочерние данные (например, связанные товары) не удаляются, что нарушает целостность базы данных. Вам нужно устранить эту проблему.  
Какой подход вы выберете для сохранения целостности данных при удалении зависимых ресурсов?  

- Добавить проверку зависимых данных перед удалением  
- Установить для дочерних записей статус "без родителя"  
- Переключить метод DELETE на PATCH, чтобы обновлять статус записей  
- Настроить каскадное удаление для связанных ресурсов  
- Переключиться на пометку заказов как удаленных, без их физического удаления  

---

## Вопрос 24  
Вы используете WebSocket для передачи данных клиентам. Некоторые клиенты сталкиваются с обрывом соединения из-за проблем в сети. Вам нужно обеспечить восстановление соединения и надежную доставку пропущенных уведомлений.  
Как обеспечить восстановление WebSocket соединения и надёжную доставку уведомлений, пропущенных из-за сетевых сбоев?  

- Использовать брокер сообщений для хранения событий до их доставки клиенту  
- Устанавливать ограничение на определенное количество попыток повторного подключения  
- Переключиться на HTTP Polling, чтобы гарантировать доставку данных  
- Сохранять все уведомления на стороне клиента до восстановления соединения  
- Использовать механизм повторного подключения WebSocket с проверкой состояния  

---

## Вопрос 25  
Команда постепенно дробит монолит API на микросервисы. Для каждого сервиса нужно выстроить единый процесс выпуска и сопровождения OpenAPI-спецификаций без ручных правок, чтобы:  
1. CI/CD pipeline блокировал слияние, если реализация расходится со спецификацией  
2. После успешного прохождения тестов автоматически генерировалась читаемая HTML документация  
3. Каждая версия спецификации сохранялась в Git-теге соответствующего релиза  
4. Из актуальной спецификации автоматически выпускались SDK клиенты (TypeScript и Python)  
5. При рефакторинге эндпоинтов не возникал «дрифт» между кодом и спецификацией  
Какое минимальное сочетание решений покрывает все пять требований?  

- 1 + 3  
- 1 + 2 + 3  
- 2 + 4  
- 1 + 3 + 4  
- 1 + 2 + 4  

---

## Вопрос 26  
Ваш API поддерживает как JSON, так и XML для запросов и ответов. Некоторые клиенты отправляют запросы в одном формате, но хотят получать ответы в другом. Какой механизм наиболее эффективно поддержит этот функционал?  

- Предоставить API, которое автоматически конвертирует запросы XML в JSON  
- Использовать для этого заголовки Content-Type и Accept  
- Использовать сканирование для ответа в формате, наиболее часто используемом клиентами  
- Определить формат ответа на основе формата запроса  
- Поддерживать только JSON в запросах и использовать URL параметры  

---

## Вопрос 27  
При оформлении заказа нужно выполнить несколько действий: проверить наличие товара, рассчитать стоимость доставки и создать запись заказа. Все действия должны выполняться как единая атомарная операция: если одно не удалось, остальные отменяются. Какой подход в GraphQL следует применить?  

- Использовать отдельные Directive для проверки склада и расчета доставки  
- Использовать Query для каждой операции по отдельности  
- Выполнить несколько последовательных запросов Query с локальной транзакцией на клиенте  
- Настроить Subscription на создание заказа для получения уведомлений о статусе  
- Применить Mutation, объединив все действия в один resolver, который обрабатывает транзакцию  

---

## Вопрос 28  
Ваш API должен быть доступен только для зарегистрированных клиентов с API-ключами. Требуется обеспечить:  
1. Доступ только для зарегистрированных клиентов  
2. Автоматическое отключение доступа при неоднократных недопустимых запросах  
3. Удобное добавление новых клиентов без изменения архитектуры  
Как использовать API Gateway для управления доступом?  

- Реализовать балансировку нагрузки для распределения запросов среди разрешенных клиентов  
- Использовать механизм rate-limiting для ограничения количества запросов от одного API-ключа  
- Включить поддержку JWT-токенов с обязательной проверкой подписи для всех запросов  
- Настроить список разрешенных API-ключей с автоматической блокировкой при нарушении  
- Добавить уровень кэширования для ускорения обработки запросов от разрешенных клиентов  

---

## Вопрос 29  
Ваш API возвращает сложные вложенные структуры данных. Учтите проблемы:  
1. Глубокие вложения увеличивают время обработки  
2. Клиенты часто используют только верхний уровень данных  
3. Сложность обработки вложенных структур  
4. Избыточность данных увеличивает размер ответа  
Какой подход лучше всего упростит работу с вложенными данными и ускорит запросы?  

- Реализовать возможность выбора глубины вложений через параметры запроса  
- Добавить JSON схемы в документацию для лучшего понимания структуры  
- Нормализовать структуры данных, создав отдельные эндпоинты для каждого уровня вложенности  
- Внедрить сканирование на уровне сложных вложений для сохранения задержек  
- Создать одну сложную конечную точку для получения всей информации сразу  