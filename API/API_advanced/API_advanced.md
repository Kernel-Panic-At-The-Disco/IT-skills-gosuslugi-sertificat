# API

## Вопрос 1  
В системе обработки медицинских данных требуется:  
1. Поддержка транзакционности операций  
2. Гарантированная доставка сообщений  
3. Соответствие HIPAA требованиям безопасности  
4. Интеграция с legacy-системами на IBM Mainframe.  
Выберите верное обоснование. Какой протокол предпочтительнее: REST или SOAP?  

- SOAP, так как WS-AtomicTransaction и WS-ReliableMessaging обеспечивают требования, а WS-Security с XML-Encryption соответствует HIPAA  
- REST с gRPC, так как HTTP/2 снижает задержки, а interceptors можно использовать для имитации транзакций  
- REST, потому что HIPAA допускает защиту данных на уровне TLS, и можно избежать сложности WS-Security  
- REST, так как OAuth 2.0 и JWT позволяют реализовать гибкую авторизацию, соответствующую требованиям HIPAA  
- SOAP, потому что WSDL позволяет типизированную интеграцию с IBM Mainframe-системами  

---

## Вопрос 2  
Вы документируете RESTful API с помощью Swagger и хотите проверить, как ваше приложение взаимодействует с различными эндпоинтами API. Документация должна включать интерактивное тестирование всех эндпоинтов. Вы хотите предоставить разработчикам возможность тестировать API без использования сторонних инструментов, таких как Postman.  
Какую последовательность действий следует выполнить в Swagger, чтобы предоставить интерактивную документацию с возможностью тестирования эндпоинтов?  

- Настроить Mock-сервер для тестирования всех эндпоинтов API  
- Добавить примеры запросов вручную в виде текстового описания к каждому эндпоинту  
- Использовать вкладку "Authorization" в Swagger для генерации токенов доступа к API  
- Настроить спецификацию OpenAPI и включить Swagger UI для автоматического отображения эндпоинтов и их тестирования  
- Создать коллекцию запросов в Postman и экспортировать их для тестирования  

---

## Вопрос 3  
При разработке защищенного API вы рассматриваете использование Basic Authentication или OAuth 2.0.  
Какое ключевое преимущество OAuth 2.0 будет для вас самым значимым по сравнению с Basic Authentication в контексте безопасности и управления доступом?  

- Упрощает настройку без необходимости дополнительных серверных модулей контроля доступа  
- Предоставляет ограниченный доступ к ресурсам через токены без передачи пароля пользователя  
- Автоматически обновляет токены при истечении их срока действия  
- Облегчает внедрение многофакторной аутентификации  
- Использует бессменные токены вместо постоянной передачи учётных данных  

---

## Вопрос 4  
В вашем API используется JWT для аутентификации. Однако пользователи столкнулись с ошибкой, после того как токен был скомпрометирован. Пользователи не могли отозвать токен, что привело к неконтролируемому доступу к ресурсам до истечения срока его действия.  
Выберите ответ, который верно описывает свойства метода JWT, которые приводят к такой ошибке.  

- JWT требуют сложного алгоритма проверки подписи, который может замедлять работу самой системы  
- Токены являются автономными и содержат всю информацию о пользователе, что делает их неподконтрольными серверу  
- JWT поддерживают обновление токенов при каждом запросе, повышая безопасность  
- Токены имеют очень короткий срок жизни, что сильно ограничивает вероятность их компрометации  
- JWT зависят от внешнего сервиса для хранения данных о сессиях  

---

## Вопрос 5  
Клиент отправляет запрос, в котором одновременно: превышает допустимый лимит запросов (rate limit), и обращается к защищённому ресурсу, не имея нужных прав доступа. Обе ошибки требуют отклонения запроса. Однако сервер должен выбрать одну и вернуть соответствующий код.  
Почему в этой ситуации предпочтительно вернуть код 403, а не 429?  

- По причине того, что 429 должен возвращаться первым, так как клиент уже нарушил лимит и это не влияет на 403  
- Так как 403 используется только для POST-запросов, тогда как 429 — для любых типов запросов  
- Так как 429 информирует о техническом ограничении, которое важнее ошибок авторизации  
- Потому что 403 отражает проблему авторизации, которая делает запрос невозможным вне зависимости от частоты обращений  
- 403 приоритетнее, так как код 429 указывает на избыточную нагрузку, которая может блокировать даже корректно авторизованные запросы  

---

## Вопрос 6  
Вы разрабатываете API для управления задачами. При попытке удалить задачу методом DELETE некоторые клиенты получают код ошибки 404 Not Found, хотя задача существует. Необходимо предотвратить ошибку и корректно удалить ресурс, обеспечивая точное указание причины ошибки, если она возникает.  
Какие действия помогут устранить проблему?  

- Проверить наличие задачи перед вызовом метода DELETE, возвращая 404 только если задача действительно не существует  
- Изменить метод DELETE на PUT, чтобы обновить ресурс  
- Установить ограничение на количество удаляемых записей в одном запросе  
- Переключиться на метод PATCH для пометки задачи как удаленной, вместо ее непосредственного удаления  
- Указывать JSON как формат передачи данных в заголовке Content-Type  

---

## Вопрос 7  
Во время обновления статуса заказа методом PATCH некоторые клиенты столкнулись с неожиданными потерями данных. Вам нужно выявить паттерн ошибок и определить, в каких ситуациях этот метод может привести к потере данных.  
Какое свойство метода PATCH может привести к потере данных при отправке пустых или отсутствующих значений в запросе? PATCH...  

- Всегда проверяет целостность всех данных перед каждой обработкой запроса  
- Обрабатывает пустые значения в запросе, заменяя текущие значения на пустые  
- Требует строгого соответствия типов данных, блокируя доступ  
- Создает копии не всех данных полностью перед новым частичным обновлением  
- Автоматически создает новый ресурс при отсутствии существующего ресурса  

---

## Вопрос 8  
Ваш API поддерживает массовую загрузку больших объемов клиентских данных. Клиенты жалуются, что при увеличении объемов записей загрузка становится слишком медленной и начинает негативно влиять на общий отклик системы. Необходимо оптимизировать процесс массовой загрузки, учитывая следующие факторы:  
1. Высокая конкурентность (множество клиентов могут одновременно загружать данные)  
2. Требование гарантировать целостность и корректность загрузки (частичная загрузка не должна сломать систему)  
3. Необходимость уменьшить общее время отклика и повысить масштабируемость  
4. Сохранить устойчивость системы: даже если одна из партий данных содержит ошибку, процесс не должен приводить к сбою всего сервиса  
Какой подход вы примените, чтобы обеспечить стабильную и эффективную массовую загрузку данных, учитывая все факторы и риск перегрузки системы?  

- Применить кэширование для часто запрашиваемых данных (например, Redis), чтобы ускорить повторные операции чтения  
- Использовать серверное сжатие данных для уменьшения объемов передаваемой информации  
- Реализовать стратегию частичных запросов с использованием пагинации или чанков, позволяющую обрабатывать данные порциями и поддерживать согласованность  
- Уменьшить размер данных, исключив необязательные поля из ответа и запроса, чтобы сохранить нагрузку  
- Переключиться на отправку данных в реальном времени через WebSocket для мгновенного отклика при загрузке крупных пакетов  

---

## Вопрос 9  
Вы используете WebSocket для передачи данных о курсах валют в реальном времени. Однако частые обновления курсов создают высокую нагрузку на сервер и пропускную способность сети. Вам нужно уменьшить количество передаваемых сообщений без потери важной информации.  
Какой подход оптимизирует передачу данных по WebSocket, снижая нагрузку, но сохраняя важную информацию?  

- Ограничить частоту отправки обновлений с помощью специальных механизмов троттлинга  
- Использовать REST API вместо WebSocket для передачи данных сообщений без потери  
- Сжимать сообщения с помощью gzip перед отправкой сообщений с важной информацией  
- Переключиться для оптимизации на SSE для однонаправленной передачи данных  
- Отправлять только изменения данных (диффы) вместо полного набора значений  

---

## Вопрос 10  
Вы планируете опубликовать свое API для внешних разработчиков и хотите предоставить актуальную документацию, которая автоматически обновляется при изменениях в коде. Список факторов:  
1. Использование аннотаций кода для генерации документации  
2. Возможность преобразования спецификации OpenAPI в различные языки программирования  
3. Генерация пользовательского интерфейса (UI), который отображает текущее состояние API  
Какие из перечисленных факторов связаны с поддержкой автоматического обновления документации в OpenAPI?  

- Только фактор 2  
- Все три фактора  
- Только фактор 1  
- Только фактор 3  
- Факторы 1 и 3  

---

## Вопрос 11  
Вы предлагаете API для нескольких внутренних подразделений, каждое из которых использует разные системы. Одни требуют XML, другие — JSON. Возникла идея поддерживать отдельные эндпоинты для каждого формата, чтобы минимизировать риск конфликтов при обновлениях. Дополнительно в компании принято соглашение, что URL, заканчивающийся на .json или .xml, поможет департаментам четко отличать эндпоинты.  
Что нужно сделать, чтобы отделить формат данных уже на уровне URL и избежать необходимости в дополнительных заголовках?  

- Реализовать два эндпоинта, например /api/v2/users.json и /api/v2/users.xml, возвращая разные форматы  
- Принимать любой запрос и всегда возвращать оба формата, вложенные в один ответ  
- Автоматически возвращать XML, если клиентская ОС Windows, и JSON — если Linux  
- Хранить в базе два разных набора данных и переключаться между ними в зависимости от названия эндпоинта  
- Настроить CDN, который разделит .json файлы из одного хранилища, а .xml — из другого  

---

## Вопрос 12  
Вы хотите добавить информацию о ролях и правах пользователя в JWT-токен, чтобы использовать его для авторизации.  
Каким образом лучше всего включить эти данные в JWT, чтобы обеспечить их безопасность и актуальность?  

- Передавать роли и права пользователя в виде зашифрованных данных в теле ответа на каждый запрос  
- Добавить роли и права в заголовок токена, чтобы они всегда были видны при передаче данных  
- Включить информацию о ролях в полезную нагрузку токена и подписывать JWT с использованием безопасного алгоритма  
- Включить роли в URL-параметры каждого запроса, чтобы не использовать сложные методы подписи  
- Хранить права и роли на сервере, а в JWT-токен добавлять только уникальный идентификатор пользователя  

---

## Вопрос 13  
Вы разрабатываете высоконагруженное GraphQL API для приложения обмена сообщениями, где требуются мгновенные уведомления о новых сообщениях и статусе пользователей (онлайн/оффлайн). При этом часть клиентов (например, мобильные) ограничены в ресурсах и не могут часто опрашивать сервер (polling). Вы также хотите избежать лишней нагрузки на инфраструктуру, так как постоянные запросы Query увеличивают нагрузку. Нужно обеспечить реальное время (real-time) получения данных, сохранив при этом гибкость и масштабируемость сервиса.  
Какой из методов GraphQL оптимально применить для организации двунаправленной связи между сервером и клиентом, позволяющей передавать обновления по мере их появления?  

- Mutation в GraphQL  
- Subscription в GraphQL  
- Resolver в GraphQL  
- Query в GraphQL  
- Directive в GraphQL  

---

## Вопрос 14  
Ваш API обслуживает тысячи клиентов, и вы замечаете, что несколько из них отправляют аномально большое количество запросов в короткий промежуток времени. Это негативно влияет на производительность и приводит к сбоям в обработке запросов других клиентов. Вам нужно внедрить гибкое ограничение нагрузки через API Gateway, которое будет учитывать:  
1. Идентификацию клиентов (например, через токены)  
2. Дифференциацию правил (например, VIP-клиенты могут отправлять больше запросов)  
3. Мгновенную блокировку клиентов, нарушающих лимиты  
Как настроить API Gateway для решения этой задачи?  

- Настроить IP-блокировку для всех клиентов, превышающих лимиты  
- Добавить правило для обработки VIP-клиентов через кастомные политики API Gateway  
- Ограничить доступ к API для всех клиентов, кроме заранее определенных групп  
- Сформировать функцию rate-limiting с динамическими лимитами, привязанными к идентификаторам клиентов  
- Использовать кэширование для временного хранения запросов и уменьшения нагрузки  

---

## Вопрос 15  
Ваш API поддерживает четыре основные версии, каждая из которых реализует схожую функциональность с незначительными изменениями. Например:  
1. Версии 1 и 2 возвращают данные в разных форматах (JSON, XML)  
2. Версия 3 добавляет параметры для фильтрации, которые отсутствуют в других версиях  
3. Версия 4 поддерживает агрегированные данные для определенных отчетов  
4. Разработчики вынуждены поддерживать эти версии, внося изменения вручную в каждую из них. Это приводит к ошибкам, задержкам и дублированию кода. Также пользователи жалуются на сложность работы с API, так как документация недостаточно детализирована для каждой версии.  
Какой подход поможет уменьшить сложность кода, сохранить обратную совместимость и упростить обновления API, сохраняя обратную совместимость для существующих клиентов?  

- Добавить возможность передачи всех параметров через единый объект, чтобы сократить количество дублирующего кода  
- Внедрить API Gateway для управления запросами к разным версиям  
- Удалить старые версии API и оставить только последнюю, предложив клиентам обновиться  
- Реализовать конвертер форматов данных на уровне клиента, чтобы уменьшить число поддерживаемых версий  
- Объединить ключевые функции из всех версий в одну универсальную реализацию, сохранив совместимость через параметры  