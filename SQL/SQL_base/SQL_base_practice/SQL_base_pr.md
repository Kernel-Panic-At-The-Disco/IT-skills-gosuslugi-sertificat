# Просмотр базы клиентов

**Описание:**  
Вы — маркетинговый аналитик в рекламном агентстве. Для рассылки пуш-уведомлений команда Performance-маркетинга запросила у вас выгрузку данных по определенной когорте пользователей: в возрасте от 18 до 24 лет включительно, которые зарегистрировались в сервисе в период проведения рекламной кампании среди студентов (с 20 по 31 января 2024 года включительно).

**Формат ввода:**  
Таблица users:
- user_id (int) — уникальный идентификатор клиента
- name (string) — имя клиента
- city (string) — город клиента
- age (int) — возраст клиента
- source (string) — источник установки
- reg_date (date) — дата регистрации клиента в сервисе

Колонка source может содержать пропуски, так как при регистрации пользователей это поле не является обязательным. Независимо от наличия этого пропуска, включайте в итоговую выгрузку всех подходящих клиентов.

**Формат вывода:**  
Запрос должен вернуть таблицу с полями в таком порядке:
- user_id (int) — уникальный идентификатор клиента
- age (int) — возраст клиента
- city (string) — город клиента
- reg_date (date) — дата регистрации клиента в сервисе

Выходные данные отсортированы по возрастанию user_id, как и входная таблица.

**Пример 1:**  
Входные данные:
| user_id | name           | city   | age | source | reg_date    |
|---------|----------------|--------|-----|--------|-------------|
| 0       | Maurice Dixon  | Paris  | 18  |        | 2024-06-05  |
| 3       | Brady Barrett  | Moscow | 22  | social | 2024-01-20  |
| 10      | Theresa Owens  | Berlin | 26  | organic| 2024-01-28  |
| 20      | Sharon Joyce   | Moscow | 17  | social | 2024-01-26  |

Выходные данные:
| user_id | age | city   | reg_date    |
|---------|-----|--------|-------------|
| 3       | 22  | Moscow | 2024-01-20  |

**Код:**
```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    name VARCHAR(255),
    city VARCHAR(255),
    age INT,
    source VARCHAR(255),
    reg_date DATE
);

INSERT INTO users (user_id, name, city, age, source, reg_date) VALUES
(0, 'Maurice Dixon', 'Paris', 18, NULL, '2024-06-05'),
(3, 'Brady Barrett', 'Moscow', 22, 'social', '2024-01-20'),
(10, 'Theresa Owens', 'Berlin', 26, 'organic', '2024-01-28'),
(20, 'Sharon Joyce', 'Moscow', 17, 'social', '2024-01-26'),
(24, 'Tyler Bubar', 'London', 24, NULL, '2024-01-31');
```
---

# Определение фродовых транзакций

**Описание:**  
Вы — антифрод-аналитик в банке. По информации службы безопасности, в выгрузке транзакций пользователей содержатся фродовые операции.

Фродеры целенаправленно внедряют паттерны в свои схемы, чтобы обмануть алгоритмы определения фрода. Выявить фродовую операцию можно по ряду условий:
1. Если номер транзакции четный, то это НЕ фродовая операция;
2. Если номер транзакции нечетный и она выполнена в Лондоне, то считается фродовой только при условии, что ее размер в 2 раза выше среднего размера транзакции любого типа;
3. Если номер транзакции нечетный и она выполнена не в Лондоне, то она считается фродовой только при условии, что ее размер в 3 раза выше среднего размера транзакции типа payment.

Для каждой транзакции определите, является ли она фродовой или нет, и добавьте флаг принадлежности к фроду.

**Формат ввода:**  
Таблица transactions:
- transaction_id (int) — уникальный идентификатор транзакции
- country (string) — страна, в которой совершена транзакция
- city (string) — город, в котором совершена транзакция
- transaction_datetime (datetime) — дата и время совершения транзакции
- type (string) — тип транзакции (оплата/возврат)
- value (float) — сумма транзакции в рублях

Из-за системной ошибки некоторые транзакции имеют пропуски в колонке type. НЕ учитывайте подобные транзакции в своих подсчетах.

**Формат вывода:**  
Запрос должен вернуть таблицу с полями в таком порядке:
- transaction_id (int) — уникальный идентификатор транзакции
- is_fraud (string) — флаг того, что транзакция является фродовой

Выходные данные отсортированы по возрастанию transaction_id, как и входная таблица.

**Пример 1:**  
Входные данные:
| transaction_id | country | city   | transaction_datetime   | type    | value      |
|----------------|---------|--------|-----------------------|---------|------------|
| 1000           | UK      | London | 2024-12-19 09:05:58   | refund  | 4765.12    |
| 1001           | UK      | London | 2024-12-21 16:00:41   | payment | 182780.70  |
| 1002           | UAE     | Dubai  | 2024-12-04 03:01:50   | payment | 3439.04    |
| 1003           | UAE     | Dubai  | 2024-12-04 18:32:43   | payment | 4701.94    |

Выходные данные:
| transaction_id | is_fraud |
|----------------|----------|
| 1000           | 0        |
| 1001           | 1        |
| 1002           | 0        |
| 1003           | 0        |

**Код:**
```sql
CREATE TABLE transactions (transaction_id INT PRIMARY KEY,
 country VARCHAR(50) NOT NULL,
 city VARCHAR(50) NOT NULL,
 transaction_datetime TIMESTAMP NOT NULL,
 type VARCHAR(10) CHECK (type IN ('payment', 'refund')),
 value DECIMAL(15,2) NOT NULL);

INSERT INTO transactions (transaction_id, country, city, transaction_datetime, type, value) VALUES
(1000, 'UK', 'London', '2024-12-19 09:05:58', 'refund', 4765.12),
(1001, 'UK', 'London', '2024-12-21 16:00:41', 'payment', 182780.70),
(1002, 'UAE', 'Dubai', '2024-12-04 03:01:50', NULL, 3439.04),
(1003, 'UAE', 'Dubai', '2024-12-04 18:32:43', 'payment', 4701.94),
(1007, 'Russia', 'Moscow', '2024-12-26 14:10:05', 'refund', 17000.11);
```

---

# Подсчет выплат сотрудникам

**Описание:**  
Вы — HR-аналитик крупной сети ресторанов быстрого питания. Вам нужно рассчитать итоговую выплату заработной платы для каждого сотрудника с учетом отработанного времени. Есть несколько требований:
- Для сотрудников, которые отработали более 24 часов, каждый последующий час оплачивается в двойном размере.
- Если сотрудник устроился совсем недавно, то в базе может не быть информации о его ставке. В таком случае выполните расчет по стандартной ставке — 500 рублей в час.
- По трудовому договору, компания оплачивает 3 больничных дня в фиксированном объеме — 1500 рублей за 1 больничный день. Сотрудник может брать и больше больничных, но оплачены будут только 3.

**Формат ввода:**  
Таблица employees:
- employee_id (int) — уникальный идентификатор сотрудника
- name (string) — имя сотрудника
- rate (decimal) — ставка за 1 час работы
- hours_worked (int) — количество отработанных часов
- sick_days (int) — количество использованных дней больничного

Если сотрудник был трудоустроен недавно, то в колонке rate у него может стоять пропуск. Для таких сотрудников замените пропуск на 500.

**Формат вывода:**  
Запрос должен вернуть таблицу с полями в таком порядке:
- employee_id (int) — уникальный идентификатор сотрудника
- value (int) — размер выплаты сотрудника

Выходные данные отсортированы по возрастанию employee_id, как и входная таблица.

**Пример 1:**  
Входные данные:
| employee_id | name             | rate | hours_worked | sick_days |
|-------------|------------------|------|--------------|-----------|
| 100000      | Michael Linnane  |      | 21           | 5         |
| 100001      | Brian Henderson  | 450  | 27           | 3         |
| 100003      | Allen Anderson   | 300  | 36           | 10        |
| 100008      | David Rodriguez  | 600  | 11           | 8         |

Выходные данные:
| employee_id | value |
|-------------|-------|
| 100000      | 25500 |
| 100001      | 23250 |
| 100003      | 20700 |
| 100008      | 12300 |

**Код:**
```sql
CREATE TABLE employees (employee_id INT PRIMARY KEY,
 name VARCHAR(100) NOT NULL,
 rate DECIMAL(10,2),
 hours_worked INT NOT NULL,
 sick_days INT NOT NULL);

INSERT INTO employees (employee_id, name, rate, hours_worked, sick_days) VALUES
(100000, 'Michael Linnane', NULL, 21, 5),
(100001, 'Brian Henderson', 450, 27, 3),
(100003, 'Allen Anderson', 300, 36, 10),
(100008, 'David Rodriguez', 600, 11, 8),
(100020, 'Stanley Rodriguez', 650, 31, 2);
```
---
