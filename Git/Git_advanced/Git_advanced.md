# **Git\_advanced**

**Вопрос 1**

Команда разработчиков решила хранить большие бинарные файлы (изображения, видео и 3D-модели) в репозитории Git. Все изменения в них фиксируются напрямую в коммитах.

Репозиторий уже содержит 2 ГБ исходного кода и документации. Ежедневно добавляется около 200 МБ новых бинарных файлов с незначительными изменениями.

Оцените, насколько правильно использовать Git в таком сценарии, и объясните, как это повлияет на производительность и размер репозитория в долгосрочной перспективе.

1. Это допустимо при условии регулярного выполнения git gc \--aggressive для оптимизации хранилища объектов и удаления избыточных данных  
2. Это некорректно, так как Git не умеет работать с файлами в кодировке, отличной от UTF-8  
3. Это допустимо, если использовать shallow clone с глубиной не более 10 коммитов при работе с репозиторием: тогда операции будут достаточно быстрыми  
4. Это некорректно: Git будет сохранять полные копии файлов при каждом изменении, это приведет к росту размера репозитория и замедлению операций  
5. Это нормальная практика: Git использует дельта-сжатие для всех типов файлов, поэтому размер репозитория будет расти линейно, а не экспоненциально

**Вопрос 2**

Вы с коллегой работаете над новой функциональностью в API в ветке feature/api-implementation. В ветку main было внесено несколько исправлений ошибок, которые также присутствуют в вашей ветке. Однако в main есть и другие изменения, несовместимые с вашей текущей веткой. Ваш коллега выполнил действия для исправления этих ошибок в вашей ветке, не затрагивая остальные функции.

Определите по текущему и предыдущему состояниям веток, какую последовательность команд выполнил ваш коллега.

Учтите: он точно не копировал изменения в вашу ветку вручную и не создавал новых коммитов с нуля.

Состояние ветки feature/api-implementation до изменений

80a8cf6: New api implementation  
Изменения в файлах: api.js, models.js  
1c69684: V2  
Изменения в файлах: config.js, utils.js  
99a9c09: V1  
Изменения в файлах: index.js, package.json

Состояние ветки main

f7d21e: UI improvements  
Изменения в файлах: ui.js, styles.css  
d5bb6ba: V3  
Изменения в файлах: config.js, database.js  
e3a91c2: Security fix  
Изменения в файлах: auth.js, api.js  
c1e97f1: API hot-fix  
Изменения в файлах: api.js  
b2d83f4: Performance optimization  
Изменения в файлах: utils.js, models.js  
1c69684: V2  
Изменения в файлах: config.js, utils.js  
99a9c09: V1  
Изменения в файлах: index.js, package.json

Текущее состояние ветки feature/api-implementation

7ae290f: Security fix  
Изменения в файлах: auth.js, api.js  
4fde353: API hot-fix  
Изменения в файлах: api.js  
2b8c1a5: Performance optimization  
Изменения в файлах: utils.js, models.js  
30a8cf6: New api implementation  
Изменения в файлах: api.js, models.js  
1c69684: V2  
Изменения в файлах: config.js, utils.js  
99a9c09: V1  
Изменения в файлах: index.js, package.json

1. git format-patch main \--stdout | git apply \--reject && git commit \-am "Apply fixes from main"  
2. git rebase \-i main \--onto \<hash\>  
3. git cherry-pick b2d83f4 c1e97f1 e3a91c2  
4. git checkout main api.js auth.js utils.js models.js && git commit \-m "Apply fixes from main"  
5. git merge main && git revert \<hash\>

**Вопрос 3**

Вы работаете над проектом и замечаете, что изменения, которые касаются исправления ошибки в форме в ветке feature/data-form, исчезли, хотя раньше они точно были.

Вы выполняете команду git log и видите следующий вывод:

1 commit 1c69684  
2 Author: Some Developer  
3 Date: Mon Dec 18 10:00:00 2024  
4 Initial implementation of form functionality

1 commit 5f62b1c  
2 Author: Some Developer  
3 Date: Mon Dec 9 18:30:00 2024  
4 Added database connection

После этого вы выполняете команду git reflog, чтобы посмотреть журнал операций с объектами в Git, и видите такой вывод:

1 5f62b1c HEAD@{0}: reset: moving to HEAD\~1  
2 a2f3143 HEAD@{1}: commit: Fix for form functionality  
3 5f62b1c HEAD@{2}: commit: Initial implementation of form functionality

Какая команда была выполнена и какую команду теперь надо выполнить, чтобы восстановить ваши изменения?

1. Выполнена git reset \--mixed, которая удалила коммит a2f3143 и оставила изменения в рабочей директории, а для восстановления надо выполнить git commit  
2. Выполнена git revert, отменившая изменения из коммита a2f3143, а для восстановления надо выполнить git revert HEAD  
3. Выполнена git reset \--hard, которая удалила коммит a2f3143, а для восстановления надо выполнить git cherry-pick a2f3143  
4. Выполнена git reset \--soft, которая удалила коммит a2f3143 и перенесла изменения в staging area, а для восстановления надо выполнить git commit  
5. Выполнена git rebase, из\-за которой коммит a2f3143 был потерян, а для восстановления надо выполнить git stash pop

**Вопрос 4**

Вы работаете в ветке feature/new-customer-model, которая была создана командой git checkout \-b feature/new-customer-model. После завершения разработки вы пытаетесь отправить изменения в удаленный репозиторий origin и выполняете команду git push origin.

Какой результат вы получите и почему?

1. Команда завершится с ошибкой, так как перед push необходимо подписать коммиты с помощью git push \-s  
2. Команда успешно завершится, а в удаленном репозитории будет создана новая ветка  
3. Команда завершится успешно, но с предупреждением о том, что была создана новая ветка  
4. Команда завершится с ошибкой, так как локальная ветка еще не связана с удаленным репозиторием  
5. Команда завершится с ошибкой, так как origin не может быть именем удаленного репозитория

**Вопрос 5**

Вы работаете в команде, использующей расширенную методологию Git Flow с дополнительными типами веток. Ваш проект имеет следующую структуру веток:

* main (стабильные релизы)  
* develop (текущая разработка)  
* release/\* (подготовка релизов)  
* hotfix/\* (срочные исправления)  
* feature/\* (новые функции)  
* experimental/\* (экспериментальные функции)  
* refactor/\* (рефакторинг кода)

Один из ваших коллег выполнил следующие действия:

* Создал ветку refactor/db-constraints от develop  
* Сделал в ней 15 небольших коммитов, каждый из которых рефакторит отдельную часть кода БД  
* Выполнил слияние ветки refactor/db-constraints в develop командой: git merge \--squash refactor/db-constraints  
* Создал новый коммит в develop с подробным описанием всех изменений  
* Не удалил ветку refactor/db-constraints после слияния

Какой из следующих выводов отражает последствия таких действий с точки зрения расширенного Git Flow и управления историей изменений?

1. Не соответствует, так как после слияния с флагом \--squash ветка refactor/db-constraints должна быть немедленно удалена, потому что ее история больше не имеет значения  
2. Не соответствует, так как ветки refactor/\* не предусмотрены в стандартной Git Flow, их следовало оформить как feature/\*  
3. Полностью не соответствует, так как в Git Flow всегда требуется использовать стандартное слияние (git merge \--no-ff) для сохранения всей истории изменений, включая промежуточные коммиты даже для веток рефакторинга  
4. Частично соответствует, но коллега должен был использовать git rebase перед слиянием, чтобы создать линейную историю, а затем выполнить fast forward merge  
5. Соответствует для веток рефакторинга, так как объединение множества мелких изменений в один логический коммит с помощью \--squash упрощает историю develop, при этом полная детализация изменений остается доступной в исходной ветке

**Вопрос 6**

Вы обнаружили ошибку в текущей версии проекта и хотите использовать команду git bisect для поиска коммита, который создал эту ошибку.

Вы знаете, что ошибка не воспроизводится в коммите с хешем 99a9c09, а хеш коммита текущей версии проекта — c1e97f1.

Какую команду надо выполнить для начала работы с git bisect?

1. git bisect bad c1e97f1  
2. git bisect good 99a9c09  
3. git bisect start 99a9c09 c1e97f1  
4. git bisect start c1e97f1 99a9c09  
5. git bisect reset

**Вопрос 7**

Для чего используется Git Submodules?

1. Для объединения нескольких репозиториев в один, чтобы они работали как единое целое  
2. Для синхронизации версий файлов между несколькими проектами  
3. Для удаления веток из другого репозитория  
4. Для работы с несколькими независимыми репозиториями в одном проекте  
5. Для отслеживания изменений в другом репозитории как части вашего текущего проекта.

**Вопрос 8**

Объясните, как технически работает Git LFS и какие преимущества он предоставляет по сравнению со стандартным Git при работе с большими файлами.

1. Git LFS позволяет подключать внешнее хранилище через Git remote и хранить большие файлы отдельно от основного репозитория, но с теми же идентификаторами коммитов  
2. Git LFS автоматически разбивает большие файлы на фрагменты и хранит только изменившиеся фрагменты при каждом коммите, это позволяет эффективно отслеживать изменения в бинарных файлах  
3. Git LFS заменяет большие файлы в репозитории на текстовые указатели (pointer files), содержащие SHA-256 хеш и метаданные, а сами файлы хранятся на отдельном LFS-сервере, это ускоряет операции клонирования и извлечения  
4. Git LFS создает отдельный репозиторий для больших файлов и автоматически синхронизирует его с основным репозиторием при выполнении команд push и pull, это уменьшает размер основного репозитория  
5. Git LFS использует специальный алгоритм сжатия для больших файлов, который эффективнее стандартного алгоритма Git, это позволяет хранить большие файлы с меньшими затратами дискового пространства

**Вопрос 9**

Ваш коллега, работая над коммитами в ветке main, заметил: история коммитов в ней содержит коммит 3256012 с очень большим файлом debug.log и другими изменениями. Этот файл уже удален из репозитория в коммите 8dd9645, но всё еще существует в истории и усложняет работу с репозиторием. Он выполнил какую-то операцию с деревом коммитов и удалил этот файл из всех предыдущих коммитов.

Начальное состояние ветки (вывод git log \--oneline):

1 f1fe759 (HEAD \-\> main) Fixed documentation and comments  
2 8dd9645 Removed debug.log  
3 c6efbed Finished main feature  
4 325b012 Added model implementation  
5 e21d3cc Initial commit

Итоговое состояние ветки (вывод git log \--oneline):

1 62db399 (HEAD \-\> main) Fixed documentation and comments  
2 af98fe5 Removed debug.log  
3 f7048f0 Finished main feature  
4 4d1dde5 Added model implementation  
5 e21d3cc Initial commit

Какую операцию из перечисленных выполнил ваш коллега?

1. Выполнил git cherry-pick для удаления файла и пересоздал коммиты вручную  
2. Выполнил git filter-branch \--tree-filter "rm \-f debug.log" \--all  
3. Выполнил git commit \--amend, удалив файл вручную, а затем перезаписал историю командой git push \--force  
4. Выполнил git filter-branch \--index-filter "git rm \--cached debug.log" \--all  
5. Выполнил git rebase \-i для редактирования коммита и удаления файла

**Вопрос 10**

Какой из следующих подходов наиболее эффективен для интеграции внешнего репозитория, когда требуется сохранить полную историю изменений внешнего проекта и иметь возможность вносить локальные изменения, не затрагивая основной репозиторий?

1. Копирование файлов вручную и добавление их в .gitignore  
2. Использование git subtree с опцией \--squash  
3. Использование git submodule с настройкой shallow clone  
4. Использование git submodule с последующим форком подмодуля  
5. Использование git subtree без опции squash

**Вопрос 11**

Разработчик случайно выполнил git reset \--hard HEAD\~3, удалив последние три коммита, которые еще не были отправлены в удаленный репозиторий.

Какая последовательность команд позволит восстановить потерянные коммиты и создать новую ветку с этими изменениями?

1. 1 git reflog  
   2 git reset \--hard HEAD@{3}  
   3 git checkout \-b recovery-branch

2. 1 git reflog show  
   2 git checkout HEAD@{3}  
   3 git checkout \-b recovery-branch

3. 1 git log \--graph \--all  
   2 git checkout \<commit\>  
   3 git checkout \-b recovery

4. 1 git log \--all  
   2 git cherry-pick \<commit-hash\>  
   3 git push origin recovery-branch

5. 1 git fsck \--lost-found  
   2 git merge ORIG\_HEAD  
   3 git branch recovery-branch

**Вопрос 12**

В вашей компании используется CI/CD-система, которая автоматически развертывает приложение на основе Git-тегов. Вам необходимо создать новый релиз v2.5.0, который должен соответствовать следующим требованиям:

1. Тег должен содержать подробное описание изменений в релизе.  
2. Тег должен быть создан для определенного коммита с хешем a7d3f1c, а не для HEAD.  
3. Тег должен быть доступен всем разработчикам через удаленный репозиторий.  
4. В системе должна сохраниться информация о том, кто и когда создал этот тег.

Какая последовательность команд Git корректно выполнит все эти требования?

1. git checkout a7d3f1c && git tag v2.5.0 && git push origin v2.5.0  
2. git tag \-a version2.5.0 a7d3f1c \-m "Release v2.5.0" && git push origin version2.5.0  
3. git checkout a7d3f1c && git tag \-s v2.5.0 \-m "Release v2.5.0" && git push \--tags  
4. git tag \-s v2.5.0 a7d3f1c \-m "Release v2.5.0" && git push \--follow-tags  
5. git tag \-a v2.5.0 a7d3f1c \-m "Release v2.5.0" && git push origin v2.5.0

**Вопрос 13**

Вы работаете над сложным проектом и сталкиваетесь со следующей ситуацией:

1. В ветке feature/auth вы внесли изменения в несколько файлов, часть из которых уже добавлена в индекс (staged).  
2. Вам срочно нужно переключиться на ветку hotfix/security для исправления критической уязвимости.  
3. Вы хотите сохранить только изменения в файлах, связанных с аутентификацией (auth\*.js), но отбросить остальные изменения.  
4. После завершения работы над hotfix вам нужно вернуться к работе над аутентификацией и восстановить только сохраненные изменения.  
5. Вы хотите сохранить изменения локально, не отправляя их в удаленный репозиторий.

Какая из последовательностей команд Git позволит выполнить все эти действия?

1. 1 git stash  
   2 git checkout hotfix/security  
   3 \[работа над hotfix\]  
   4 git checkout feature/auth  
   5 git stash pop

2. 1 git stash push \-m "auth changes" auth.js  
   2 git checkout hotfix/security  
   3 \[работа над hotfix\]  
   4 git checkout feature/auth  
   5 git stash pop

3. 1 git add auth\*.js  
   2 git stash  
   3 git reset hard  
   4 git checkout hotfix/security  
   5 \[работа над hotfix\]  
   6 git checkout feature/auth  
   7 git stash apply

4. 1 git stash save "auth changes"  
   2 git checkout hotfix/security  
   3 \[работа над hotfix\]  
   4 git checkout feature/auth  
   5 git stash apply stash@{0}

5. 1 git commit \-am "WIP: auth changes"  
   2 git checkout hotfix/security  
   3 \[работа над hotfix\]  
   4 git checkout feature/auth  
   5 git reset HEAD\~1

**Вопрос 14**

В проекте с микросервисной архитектурой обнаружена критическая уязвимость безопасности, внесенная коммитом abc123 два месяца назад. Этот коммит затрагивает общую библиотеку аутентификации, используемую во всех сервисах. Ситуация осложняется следующими факторами:

1. После проблемного коммита было сделано более 200 коммитов в основной ветке.  
2. От основной ветки было создано пять релизных веток, в которых также есть этот коммит.  
3. Несколько команд разработчиков создали feature-ветки от разных точек истории.  
4. Некоторые последующие коммиты в основной ветке частично исправляют проблему, но не полностью.  
5. Все затронутые ветки уже развернуты в различных средах (тестовой, препродакшен, продакшен).

Какая стратегия будет эффективной для устранения уязвимости во всех ветках с минимальным риском нарушения работы проекта?

1. Создать hotfix-ветку от точки до проблемного коммита, внести исправления и выполнить слияние этой ветки со всеми затронутыми ветками  
2. Использовать git rebase \-i для редактирования проблемного коммита в каждой ветке, с последующим принудительным обновлением (force-push)  
3. Использовать git bisect для точного определения проблемного кода, создать патч и применить его ко всем веткам с помощью git am  
4. Создать единый исправляющий коммит с помощью git revert abc123 в основной ветке и затем выполнить cherry-pick этого коммита во все релизные ветки  
5. Создать серию revert-коммитов для проблемного коммита и всех коммитов, которые частично его исправляли, затем создать новый коммит с полным исправлением

**Вопрос 15**

Вы работаете над проектом. В ветке feature/mvp у вас есть несколько коммитов, и вы хотите исправить последние три коммита, включая текущий.

В одном из них есть ошибка, которую вы хотите исправить, а в другом неудачное название.

Вы хотите изменить порядок коммитов, исправить ошибку и изменить название коммита, чтобы улучшить историю проекта перед push изменений в основную ветку.

Какую команду в Git надо использовать, чтобы выполнить всё это в интерактивном режиме?

1. git reset \-i HEAD\~3  
2. git merge \--no-ff feature/mvp  
3. git rebase \-i HEAD\~3  
4. git cherry-pick HEAD\~3  
5. git pull \--rebase \-i HEAD\~3