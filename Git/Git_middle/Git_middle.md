# **Git\_middle**

**Вопрос 1**

Вы работаете над проектом и замечаете, что в репозиторий проекта случайно добавлен файл secrets.json. Он уже фигурирует в нескольких коммитах. Вы хотите удалить этот файл и убедиться, что он станет недоступен для восстановления в локальном и удаленном репозиториях. Это изменение не должно затрагивать другие файлы проекта и коммиты.

Выберите последовательность действий для решения этой задачи.

1. Выполнить команду git rm secrets.json, зафиксировать изменения и сделать git push в удалённый репозиторий  
2. Добавить файл secrets.json в файл .gitignore, зафиксировать изменения и сделать git push в удалённый репозиторий  
3. Использовать команду git stash, чтобы добавить файл в stash, а потом сделать git push \--force в удалённый репозиторий  
4. Выполнить команду git filter-branch \--tree-filter 'rm \-f secrets.json' HEAD и сделать git push \--force в удалённый репозиторий  
5. Удалить файл secrets.json из папки с проектом, зафиксировать изменения и сделать git push в удалённый репозиторий

**Вопрос 2**

Вы работаете в команде над проектом, анализирующим логи веб\-сервера. Вы обнаружили следующую ситуацию в репозитории: файл logs/initial.log отслеживается Git, хотя, согласно документации, он должен создаваться автоматически при каждом запуске тестов и не подлежит контролю версий.

В файле .gitignore уже присутствуют следующие строки:

1 logs/\*.log  
2 logs/sample-\*.log

Проанализируйте ситуацию и определите, какое из следующих утверждений является верным относительно текущего состояния отслеживания файлов и потенциальных проблем.

1. Файл logs/initial.log будет игнорироваться, так как правило logs/\*.log имеет более высокий приоритет. Файлы logs/sample.log не будут отслеживаться из\-за этого же правила. Временные файлы logs/tmp-\*.log также будут игнорироваться  
2. Файл logs/initial.log будет игнорироваться Git, а файлы logs/sample.log будут отслеживаться корректно. Временные файлы logs/tmp-\*.log также будут игнорироваться  
3. Файл logs/initial.log продолжит отслеживаться Git, так как он уже находится под версионным контролем. Файлы logs/sample-\*.log будут отслеживаться, а файлы logs/tmp-\*.log будут игнорироваться  
4. Файл logs/initial.log продолжит отслеживаться. Файлы logs/sample-\*.log будут отслеживаться, так как исключающее правило logs/sample-log имеет более высокий приоритет. Временные файлы logs/tmp-\*.log также будут отслеживаться  
5. Файл logs/initial.log будет игнорироваться, а отслеживание файлов logs/sample.log и игнорирование logs/tmp-\*.log будет зависеть от порядка их создания относительно коммитов

**Вопрос 3**

Ваша команда работает над проектом, который требует четкого разделения веток по этапам разработки, тестирования и релиза. Также нужна полная стабильность основной ветки и поддержка возможности исправления ошибок в релизе без влияния на текущую разработку.

Ваша команда поддерживает сразу несколько релизов продукта одновременно.

Какая методология Git лучше всего подходит для вашей команды?

1. Использование Git Flow изменение будет сразу попадать в основную ветку после пройденного ревью  
2. Создание группы веток для каждой задачи (тестирование, разработка и релиз), а также слияние группы веток с основной веткой после завершения задачи и тегирование ветки сразу после слияния  
3. Использование одной ветки и маркировка ее тегами после каждого коммита  
4. Использование Git Flow с двумя основными ветками, develop и master, и дополнительными ветками для релизов и исправления ошибок  
5. Использование trunk-based development все изменения сразу же попадают в одну основную ветку

**Вопрос 4**

Вы внесли изменения в локальную ветку feature/login и хотите отправить их в удаленный репозиторий. Однако при попытке выполнения команды git push origin feature/login система показывает сообщение об ошибке:

1 error: Failed to push some refs to 'origin'  
2 hint: Updates were rejected because the remote contains work that you do not have locally.  
3 hint: Integrate the remote changes (e.g., 'git pull ...') before pushing again.

Ваша команда активно работает над этой веткой, и вы знаете, что коллега недавно внес важные изменения в удаленный репозиторий. Вам нужно сохранить ваши локальные изменения, интегрировать удаленные изменения и не нарушить работу других разработчиков.

Какая последовательность действий подходит для решения задачи?

1. Выполнить git fetch origin, затем git merge \--strategy-option theirs origin/feature/login и git push origin feature/login  
2. Использовать git push \-f origin feature/login для перезаписи удалённых изменений, предварительно сделав резервную копию ветки  
3. Создать новую ветку feature/login-fix, выполнить в ней git pull origin feature/login и вручную перенести изменения, создать pull request  
4. Выполнить git pull \--rebase origin feature/login и разрешить возможные конфликты, а потом выполнить git push origin feature/login  
5. Выполнить git stash, git pull origin feature/login и git stash apply, а после разрешения конфликтов git push

**Вопрос 5**

Вы с коллегой работаете над новым UI для блока заказов в ветке feature/order-block. Ваш коллега случайно удалил ключ API из проекта и сделал push этих изменений. Потом он исправил ошибку, и после обновления репозитория ключ API был восстановлен. Что сделал ваш коллега, чтобы получить такое состояние репозитория?

Текущее состояние ветки feature/order-block:

1 08a46f0: Rev "Removed API parameter"  
2 caae1f9: Removed API parameter  
3 674c07e: Added order block styles  
4 e626b2b: Added order-block  
5 7b35cfa: V2  
6 d96d81b: V1

Начальное состояние ветки feature/order-block:

1 caae1f9: Removed API parameter  
2 674c07e: Added order block styles  
3 e626b2b: Added order-block  
4 7b35cfa: V2  
5 d96d81b: V1

1. Создал ветку feature/order-block-2 и перенес в нее все коммиты из старой ветки, используя git cherry-pick  
2. Выполнил git reset \--soft HEAD\~1, чтобы полностью отменить последний коммит, потом git commit и далее git push  
3. Переместил ошибочные изменения в другую ветку с помощью git stash, а затем удалил их из основной ветки  
4. Выполнил git revert HEAD, чтобы создать коммит, отменяющий изменения последнего коммита  
5. Выполнил git reset \--hard HEAD\~1 и после этого git push \--force в удаленный репозиторий

**Вопрос 6**

Вы работаете над проектом и подозреваете, что случайно внесли изменения в файл data.txt.

Чтобы понять, какие строки были изменены, вы хотите сравнить текущие изменения в файле с последним зафиксированным состоянием в репозитории.

Какую команду и с какими параметрами надо использовать для этого?

1. git log \-p data.txt  
2. git diff all  
3. git diff data.txt  
4. git show HEAD:data.txt  
5. git diff \--staged

**Вопрос 7**

Вы закончили работу над новой функциональностью в ветке feature/data-processing, теперь вам нужно объединить ее с веткой main. В процессе работы вы сделали несколько промежуточных коммитов, однако вы хотите минимизировать число коммитов в ветку main, чтобы сохранить чистоту истории.

Какую команду или набор команд нужно выполнить для этого?

1. git rebase main в ветке feature/data-processing, а затем git push  
2. git cherry-pick feature/data-processing  
3. git merge \--squash feature/data-processing  
4. git rebase feature/data-processing  
5. git merge feature/data-processing

**Вопрос 8**

Вы работаете над функциональностью поиска в ветке feature/search в вашем проекте. В результате какой-то операции вы получили следующее состояние вашей ветки:

1 feature/search:  
2 d98338a: Fix for search  
3 b5ff03b: Added search functions  
4 25d6a19: V2  
5 893462d: V1

История вашей ветки до выполнения операции была следующей:

1 feature/search:  
2 bcbe3f9: Fix for search  
3 1186317c: Added search functions  
4 8934b2d: V1

История ветки main выглядит так:

1 main:  
2 25d6a19: V2  
3 8934b2d: V1

Какую команду и с какими параметрами выполнили для получения такого состояния?

1. git commit \-am "V2" в ветке feature/search  
2. git merge main в ветке feature/search  
3. git rebase main в ветке feature/search  
4. git merge \--no-ff main в ветке feature/search  
5. git pull main \--rebase в ветке feature/search

**Вопрос 9**

Соотнесите команду Git с ее назначением при работе с тегами:

1. git tag \<tagname\>  
2. git tag \-a \<tagname\> \-m "Message"  
3. git push origin \<tagname\>

А. Создает аннотированный тег

В. Отправляет конкретный тег на удаленный репозиторий

С. Создает легковесный тег

1. 1-C, 2-B, 3-A  
2. 1-A, 2-C, 3-B  
3. 1-B, 2-C, 3-A  
4. 1-C, 2-A, 3-B  
5. 1-A, 2-B, 3-C

**Вопрос 10**

Вы создали новую локальную ветку feature/caching, потом сделали в ней несколько изменений и зафиксировали их. Теперь вы хотите отправить эту ветку на код-ревью — для этого вам нужно создать ветку с таким же именем в удаленном репозитории, добавить в нее все сделанные локально коммиты, а также связать локальную и удаленную ветки.

Какую команду вы выполните для этого?

1. git push origin feature/caching  
2. git branch \--track feature/caching origin/feature/caching  
3. git push \--set-upstream origin feature/caching  
4. git fetch origin feature/caching  
5. git pull origin feature/caching

**Вопрос 11**

Вы выполняете команду git merge feature/logout для объединения ветки feature/logout в текущую ветку, но сталкиваетесь с конфликтами в нескольких файлах.

Какое действие надо выполнить, чтобы разрешить конфликты и завершить процесс слияния?

1. Вручную отредактировать конфликтующие файлы, сохранить изменения и выполнить git rebase \--continue  
2. Использовать команду git stash pop для отмены конфликта  
3. Выполнить git reset hard для отмены всех изменений в конфликтующих файлах  
4. Вручную отредактировать конфликтующие файлы, сохранить изменения и выполнить git merge abort  
5. Вручную отредактировать конфликтующие файлы, сохранить изменения и выполнить git add для них, а затем git commit

**Вопрос 12**

Вы работаете в команде разработчиков над крупным проектом. Ваша задача создать оптимальный файл .gitignore, который должен соответствовать следующим требованиям:

1. Игнорировать все файлы с расширением .log во всех директориях проекта.  
2. Не игнорировать файлы .log, находящиеся в директории src/test/resources/cases, так как они содержат тестовые данные.  
3. Игнорировать всё содержимое папки tmp, которая используется для временных файлов, кроме файла tmp/initial-data.json, который содержит начальные настройки.  
4. Дополнительно игнорировать все файлы с расширением .tmp в корне проекта, но не в поддиректориях.

Какой из следующих вариантов файла gitignore соответствует всем указанным требованиям?

1. 1.log  
   2 src/test/resources/cases/\*.log  
   3 tmp/\*\*  
   4 \!tmp/initial-data.json  
   5 ./\*.tmp

2. 1 \*\*/\*.log  
   2 \!src/test/resources/cases/\*\*/\*.log  
   3 /tmp/  
   4 \!/tmp/initial-data.json  
   5 /\*.tmp

3. 1 \*\*/\*.log  
   2 \!src/test/resources/cases/\*\*/\*.log  
   3 /tmp/  
   4 \!/tmp/initial-data.json  
   5 /.tmp

4. 1 \*\*/\*.log  
   2 \!/src/test/resources/cases/\*.log  
   3 /tmp/  
   4 \!/tmp/initial-data.json  
   5 \*\*/\*.tmp

5. 1 .log  
   2 \!src/test/resources/cases/\*.log  
   3 tmp/\*  
   4 tmp/initial-data.json  
   5 .tmp  
