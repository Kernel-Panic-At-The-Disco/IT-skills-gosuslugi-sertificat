# Python_advanced

## Вопрос 1
Для какой пары встроенных типов данных попытка применения операции '+' НЕ приведёт к ошибке?

- Список и строка
- Булево значение и вещественное число
- Кортеж и список
- Целое число и список
- Строка и кортеж

---

## Вопрос 2
Что будет выведено в терминал в результате выполнения следующего кода?

```python
for i in range(0,2):
    for j in range(0,i+1):
        for k in range(j,i+1):
            print(k, end = '')
```

- 01012123
- 012
- 012012312345
- 0120123123
- Сообщение об ошибке

---

## Вопрос 3
Что будет выведено в терминал в результате выполнения следующего кода?

```python
def f(s):
    return s + s
print(f(f('ab')))
```

- 'abababab'
- 'ab', 'abab' и 'ababab'
- 'aaaabbbb'
- 'ab'
- 'ab', 'aabb' и 'aaaabbbb'

---

## Вопрос 4
Что будет выведено в терминал в результате выполнения следующего кода?

```python
r = range(3,0,-1)
for i in range(0,4):
    print(all(r), end = '')
```

- 321
- True True False
- True True True True
- True False False False
- 321321321321

---

## Вопрос 5
Что произойдёт при попытке выполнения следующего кода?

```python
class C:
    def f():
        pass
class D:
    def f(self):
        pass
class E(C,D):
    def f(self):
        super().f()
E().f()
```

- Будет вызван метод класса D, поскольку подходящий метод отсутствует в классе C
- Произойдёт ошибка, связанная с попыткой вызвать функцию от списка
- Произойдёт ошибка, связанная с отсутствием метода у объекта класса
- Произойдёт ошибка, связанная с передачей неправильного числа аргументов
- Будет вызван метод класса C

---

## Вопрос 6
Какой генератор списков транспонирует (заменяет строки на столбцы) матрицу m?

- [[m[j][i] for j in range(len(m[i]))] for i in range(len(m))]
- [[m[j][i] for j in range(len(m))] for i in range(len(m[j]))]
- [m[:] for i in range(len(m))]
- [m[i][j] for i in range(len(m))]
- [m[j][i] for i in range(len(m))]

---

## Вопрос 7
Выберите вариант, НЕВЕРНО перечисляющий встроенные модули

- itertools, pickle, os
- datetime, json, csv
- http, sqlite3, threading
- re, numpy, json
- pickle, multiprocessing, functools

---

## Вопрос 8
В чём разница между использованием with и open() close() при работе с файлами?

- with не создаёт файл в случае его отсутствия
- При использовании with нельзя открыть файл в режиме записи
- При их использовании нужно работать с объектами различных классов
- with не позволяет передать режим открытия в качестве параметра
- with корректно закрывает файл даже при возникновении ошибки

---

## Вопрос 9
Какая строка целиком соответствует следующему регулярному выражению?

```
^(\d+)\,\w*\[\+-\]?\s?(\d+)$
```

- '123 "456a'
- '12-abc'
- '12.34+-56.78'
- 'abc"123'
- '123"456'

---

## Вопрос 10
Какие аргументы можно передать в map()?

- Произвольное число функций и итерируемых объектов
- Одну функцию, произвольное число итерируемых объектов и словарь аргументов
- Одну функцию, один итерируемый объект и произвольное число аргументов функции
- Одну функцию и произвольное число итерируемых объектов
- Одну функцию, произвольное число итерируемых объектов и произвольное число аргументов функции

---

## Вопрос 11
В каком случае требуется использовать пользовательские типы ошибок?

- Когда нужно использовать несколько блоков except с одним блоком try
- Всякий раз, когда возникает ошибка, поскольку встроенные ошибки предоставляют ограниченную способность к их обработке
- Во всех случаях, когда в блоке try исполняется пользовательский код
- Когда неизвестно, какие типы ошибок способен вызвать код в блоке try
- Когда необходимо различать случаи, в которых вызывается одна и та же встроенная ошибка

---

## Вопрос 12
Что произойдёт при выполнении следующего кода?

```python
try:
    x = 1 / 0
except ZeroDivisionError:
    print("Деление на ноль!")
finally:
    print("Завершение")
```

- Программа завершится с исключением
- Будет выведено только "Завершение"
- Будет выведено только "Деление на ноль!"
- Будет выведено "Деление на ноль!" и "Завершение"
- Будет ошибка выполнения

---

## Вопрос 13
Выберите НЕВЕРНОЕ утверждение.

- Результатом выполнения рекурсивной функции всегда является изменение глобальной переменной
- Рекурсивные функции должны иметь базовый случай, останавливающий дальнейшие вызовы
- Неправильная реализация рекурсивной функции может привести к переполнению стека вызова
- Любая рекурсивная задача может быть преобразована в итеративную
- Рекурсия - это метод, при котором для решения задачи функция вызывает себя саму

---

## Вопрос 14
Какое значение примет переменная result после выполнения следующего кода?

```python
def f(n):
    if n > 0:
        yield f(n - 1)
    else:
        yield 0
result = list(f(2))
```

- [<generator object f at 0x...>, <generator object f at 0x...>, 0]
- [0, 0, 0]
- [0]
- [<generator object f at 0x...>]
- 0

---

## Вопрос 15
Выберите НЕВЕРНОЕ утверждение о модели памяти Python.

- list в Python реализован как связанный список
- Механизм сбора мусора Python способен удалять циклические ссылки
- Python переиспользует некоторые небольшие объекты, однократно выделяя под них память
- Python предоставляет возможность ручного освобождения памяти
- Python реализует счётчик ссылок для каждого объекта

---

## Вопрос 16
Выберите НЕВЕРНОЕ утверждение.

- Многопоточные программы могут использовать несколько ядер процессора
- И многопоточность, и асинхронность используются в программах, требующих параллелизма вычислений
- Многопоточность и асинхронность реализуются встроенными модулями Python
- Многопоточность и асинхронность реализуют одновременное выполнение задач
- Асинхронность работает на программном, а не на аппаратном уровне

---

## Вопрос 17
Что приводит к ошибке при попытке выполнения следующего кода?

```python
float(complex(1, 2)) + None
```

- Попытка приведения комплексной части числа к вещественному
- Попытка привести выражение в строке
- Попытка привести строку к комплексному числу
- Попытка индексации комплексного числа
- Попытка сложить вещественное число и NoneType

---

## Вопрос 18
Функция primes(ps) предназначена для возврата списка из простых чисел, начиная с 2 или с числа, следующего за последним в списке ps, если он передан. Какой из предложенных вариантов устраняет проблему?

```python
def primes(ps = []):
    start = 2 if not ps else ps[-1] + 1
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True
    num = start
    while len(ps) < n:
        if is_prime(num):
            ps.append(num)
        num += 1
    return ps
```

- Заменить ps=[] на ps=None и start = 2 if not ps else ps[-1] + 1 на start = 2 if ps is None or not ps else ps[-1] + 1
- Заменить ps=[] на ps=None и start = 2 if not ps else ps[-1] + 1 на start = 2 if not ps else ps[-1] + 2
- Вынести ps=[] в начало функции
- Заменить ps=[] на ps=None, остальной код без изменений
- Заменить ps=[] на ps=None и добавить условие if ps is None: ps = [] в начало функции

---

## Вопрос 19
Что произойдёт при попытке выполнения следующего кода?

```python
class N:
    dal():
        pass
class M:
    def f():
        pass
class C(N, M):
    pass
C().f()
```

- Будет вызван метод класса N
- Ошибка, связанная с отсутствием метода в классе C
- Ошибка, связанная с конфликтом имён
- Ошибка: множественное наследование не поддерживается
- Будет вызван метод класса M

---

## Вопрос 20
Какой вариант возвращает список, который содержит элементы исключительно под главной диагональю (слева направо) квадратной матрицы m?

- [row[j] for row in m] for j in range(len(m[0])) if i < j]
- [m[i][j] for i in range(len(m))] for j in range(len(m[i]))]
- [m[i][j] for i, row in enumerate(m) for j, val in enumerate(row) if i > j]
- [m[i][j] for i in range(len(m))] for j in range(len(m[i])) if i != j]
- [m[j][i] for i in range(len(m[0])) for j in range(len(m)) if i > j]

---

## Вопрос 21
Выберите вариант, НЕВЕРНО перечисляющий встроенные модули

- datetime, json, csv
- http, sqlite3, threading
- itertools, pickle, os
- re, numpy, json
- pickle, multiprocessing, functools

---

## Вопрос 22
Какое из следующих утверждений верно?

- Для открытия файла в режиме 'r+' необходимо, чтобы файл существовал заранее
- Метод truncate() нельзя применять к файлам в режиме 'r+'
- Метод seek() нельзя применять к файлам в режиме 'a'
- Метод append() добавляет данные в конец файла, не изменяя его содержимое
- В метод seek() необходимо передать два аргумента

---

## Вопрос 23
Какое регулярное выражение полностью соответствует предложению, которое состоит из разделённых пробелами слов и заканчивается точкой?

- ^(\w+\s)*\w+\.$
- ^(\w+\s)*\w*\.$
- ^(\w+\s)*\w+\.\s?$
- ^\w+(\s\w+)*\.$
- ^\w+(\s\w+)*\.?$

---

## Вопрос 24
Какие аргументы можно передать в map()?

- Одну функцию, один итерируемый объект и произвольное число аргументов функции
- Одну функцию и произвольное число итерируемых объектов
- Одну функцию, произвольное число итерируемых объектов и произвольное число аргументов
- Произвольное число функций и итерируемых объектов
- Одну функцию, произвольное число итерируемых объектов и словарь аргументов

---

## Вопрос 25
Что будет выведено в терминал по результатам выполнения кода?

```python
try:
    print("Начало")
    raise KeyError("Ошибка KeyError")
except KeyError:
    print("Обработка KeyError")
finally:
    print("Блок finally")
```

- Ошибка выполнения
- Начало, Key Error, Обработка KeyError
- Начало, Обработка KeyError, Блок finally
- Только "Начало"
- Начало, После вызова, Обработка KeyError, Блок finally

---

## Вопрос 26
Выберите НЕВЕРНОЕ утверждение.

- Глубина рекурсии функций ограничена
- Использование next() с пустым итератором вернёт None
- Списки не являются итераторами
- Декоратор может быть реализован без использования оператора @
- Генераторы являются итераторами

---

## Вопрос 27
Что произойдёт в результате выполнения следующего кода?

```python
def f(a,b):
    if b == 0:
        return a
    else:
        return f(a + 1, b - 1)
def g(a,b):
    if b == 0:
        return a
    else:
        return f(g(a,b-1), b - 1)
x = g(0,4)
```

- Переменная x примет значение 12
- Переменная x примет значение 0
- Попытка выполнить код приведёт к ошибке
- Переменная x примет значение 24
- Переменная x примет значение 10

---

## Вопрос 28
Выберите НЕВЕРНОЕ утверждение об операторе del.

- Объект удаляется непосредственно сборщиком мусора
- del может использоваться для удаления атрибута объекта
- del удаляет все ссылки на объект
- del может использоваться для удаления элемента списка
- del может использоваться для удаления функции

---

## Вопрос 29
Выберите верное утверждение.

- Многопоточность позволяет выполнять несколько потоков одновременно, тогда как асинхронность использует один поток для выполнения нескольких задач в период завершения.
- Многопоточность и асинхронность в Python являются взаимозаменяемыми концепциями и могут использоваться для достижения одинаковых результатов
- Многопоточность используется в задачах, где время ожидания ответа на запрос может быть значительным, а асинхронность - в задачах, требующих высокой вычислительной мощности
- Асинхронность всегда требует использования нескольких потоков, в то время как многопоточность может работать в одном потоке
- Асинхронность требует использования модуля threading для организации неблокирующих операций

---