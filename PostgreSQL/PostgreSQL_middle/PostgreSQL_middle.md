# **PostgreSQL\_middle**

**Вопрос 1**

На какой тип данных нельзя применить ограничение уникальности (unique constraint)?

1. json  
2. timestamp  
3. smallint  
4. serial  
5. jsonb

**Вопрос 2**

Была создана специальная последовательность, генерирующая только четные числа, с названием even\_sequence. Что нужно подставить на место пропуска \[...\], чтобы в случае, если значение even\_column не было указано при вставке, значение бралось из even\_sequence?

1 CREATE TABLE some\_table (  
2   even\_column \[...\]  
3 );

1. integer generated by even\_sequence  
2. integer unique default nextval('even\_sequence')  
3. integer generated always as identity (start with 2 increment by 2\)  
4. integer default nextval('even\_sequence')  
5. integer computed as nextval('even\_sequence')

**Вопрос 3**

У вас есть две связанные таблицы: first\_table и second\_table. Вы хотите выполнить команду TRUNCATE TABLE second\_table CASCADE;, чтобы удалить все строки из таблицы second\_table и всех зависимых от нее данных. Какие последствия может иметь выполнение этой команды?

1 CREATE TABLE first\_table (  
2   id INTEGER PRIMARY KEY  
3 );  
4  
5 CREATE TABLE second\_table (  
6   id SERIAL PRIMARY KEY,  
7   first\_table\_fk INTEGER REFERENCES first\_table(id)  
8 );

1. При последующей вставке в second\_table дефолтное значение для id может начинаться с некорректного значения.  
2. Существующие индексы для second\_table будут удалены и автоматически пересозданы.  
3. Последовательность second\_table\_id\_seq будет сброшена до начального значения.  
4. Возникнет ошибка, так как команда CASCADE запрещена для таблиц с внешними ключами.  
5. Удалятся все записи из first\_table, связанные через внешний ключ с second\_table.

**Вопрос 4**

Была создана таблица, в которую добавили записи. Добавление записей в таблицу происходило из нескольких мест, и в каждом случае нужно было учитывать следующую логику: price \> 0 && price \> discount && discount \> 0\. Поскольку вставка происходила из нескольких мест, было решено перенести эти ограничения на уровень базы данных, чтобы случайно не вставить некорректные данные. Был выполнен запрос, указанный ниже.

С какими проблемами можно столкнуться?

1 \-- таблица  
2 CREATE TABLE prices\_list (  
3   id SERIAL PRIMARY KEY,  
4   product\_id INT NOT NULL,  
5   price NUMERIC NOT NULL,  
6   discount NUMERIC,  
7   valid\_from DATE NOT NULL,  
8   valid\_to DATE NOT NULL  
9 );  
10 \-- запрос  
11 ALTER TABLE prices\_list  
12 ADD CONSTRAINT price\_discount\_check  
13 CHECK (  
14   price \> 0  
15   AND discount \> 0  
16   AND price \> discount  
17 );

1. Проблемы возникнут, если discount имеет значение NULL, так как NULL в логических операциях делает условие неопределённым.  
2. Ограничение будет применено только к новым записям, что может потребовать дополнительной валидации для существующих данных.  
3. Названию ограничения (constraint) нужно явно указать связанные колонки, иначе оно не будет применено.  
4. Логические операторы в условии нужно заключить в дополнительные скобки, иначе приоритет их выполнения нарушится.  
5. Ограничение невозможно применить из\-за отсутствия индексированного столбца в условии.

**Вопрос 5**

Создана структура таблиц, указанная на изображении. Необходимо выполнить запрос, указанный на изображении. Какой вид join необходимо использовать на месте пропуска \[...\], чтобы в результате для записей с type \= 'table\_aw' была заполнена колонка naming, а для записей с type \= 'table2' — колонка serial\_number?

1 CREATE TABLE multirelation (  
2   type VARCHAR NOT NULL,  
3   entity\_id INTEGER NOT NULL  
4 );  
5  
6 CREATE TABLE table\_aw (  
7   id INTEGER PRIMARY KEY,  
8   naming VARCHAR NOT NULL  
9 );  
10  
11 CREATE TABLE table2 (  
12   id INTEGER PRIMARY KEY,  
13   serial\_number VARCHAR NOT NULL  
14 );  
\-- структура таблиц  
15  
16 SELECT m.type, m.entity\_id, ta.naming, t2.serial\_number  
17 FROM multirelation m  
18 \[...\] JOIN table\_aw ta ON m.entity\_id \= ta.id AND m.type \= 'table\_aw'  
19 \[...\] JOIN table2 t2 ON m.entity\_id \= t2.id AND m.type \= 'table2';  
\-- запрос

1. cross  
2. left  
3. right  
4. inner  
5. Оставить пустым

**Вопрос 6**

В базе данных есть таблица departments, где хранится информация о департаментах компании, и таблица employees, где хранятся данные о сотрудниках. На колонку department\_id в таблице employees установлен внешний ключ, ссылающийся на id в таблице departments. Для какой из приведённых конструкций будет выдана ошибка при создании таблицы employees?

1 CREATE TABLE departments (  
2   id SERIAL PRIMARY KEY,  
3   name TEXT NOT NULL  
4 );  
5  
6 CREATE TABLE employees (  
7   employee\_id SERIAL PRIMARY KEY,  
8   department\_id \[...\],  
9   REFERENCES departments(id)  
10 );

1. bigint  
2. numeric  
3. bigserial  
4. serial  
5. integer

**Вопрос 7**

Какое выражение на месте пропуска \[...\] автоматически приведет к созданию индекса?

1 CREATE TABLE some\_table (  
2   col\_name \[...\]  
3 );

1. references other\_table(col\_name)  
2. not null  
3. serial  
4. unique  
5. integer check (col\_name \> 0\)

**Вопрос 8**

У вас есть таблица orders, в которой выполняются частые запросы на фильтрацию по колонке customer\_id и сортировку по order\_date. Какой индекс необходимо создать, чтобы одновременно ускорить фильтрацию и сортировку?

1 CREATE TABLE orders (  
2   order\_id SERIAL PRIMARY KEY,  
3   customer\_id INTEGER NOT NULL,  
4   order\_date DATE NOT NULL  
5 );

1. Нет необходимости создавать индекс, достаточно использовать PRIMARY KEY для order\_id.  
2. CREATE INDEX \<index\_name\> ON orders (order\_date) USING HASH;  
3. CREATE INDEX \<index\_name\> ON orders (order\_date, customer\_id);  
4. CREATE UNIQUE INDEX \<index\_name\> ON orders (order\_date, customer\_id);  
5. CREATE INDEX \<index\_name\> ON orders (customer\_id, order\_date);

**Вопрос 9**

В PostgreSQL заголовок версии строки включает параметр xmax. Какова его роль в управлении транзакциями?

1. Для блокировки строки от одновременных изменений несколькими транзакциями  
2. Для обозначения номера транзакции, которая удалила или обновила строку  
3. Для создания уникального идентификатора строки в таблице  
4. Для проверки видимости строки другими транзакциями  
5. Для указания максимального значения, которое может быть записано в числовую колонку

**Вопрос 10**

В PostgreSQL необходимо оптимизировать производительность транзакций за счет минимального уровня изоляции, при котором:

* параллельные транзакции могут видеть незавершённые изменения друг друга;  
* возможны "грязные чтения" (dirty read).

Какой уровень изоляции нужно указать для транзакции, чтобы достичь этой цели?

1. read uncommitted  
2. read committed  
3. dirty read невозможен в PostgreSQL  
4. serializable  
5. repeatable read

**Вопрос 11**

Существуют две транзакции. Сначала первая транзакция выполняет команду. Затем вторая транзакция выполняет команду. Далее первая транзакция продолжает выполняться.

Какая последовательность приведет к взаимоблокировке?

1 \-- первая транзакция  
2 UPDATE accounts SET balance \= balance \+ 100 WHERE id \= ?;  
3 \-- вторая транзакция  
4 UPDATE accounts SET balance \= balance \+ 50 WHERE id \= ?;  
5 UPDATE accounts SET balance \= balance \+ 200 WHERE id \= ?;

1. 1112  
2. 2112  
3. 2211  
4. 1212  
5. 1122

**Вопрос 12**

Создана следующая таблица. Вам нужно вставить новую запись через представление. Какой оператор нужно добавить на место пропуска \[...\], чтобы гарантировать, что добавляемая запись соответствует условиям представления?

1 CREATE TABLE films (  
2   id INT PRIMARY KEY,  
3   name VARCHAR NOT NULL,  
4   kind VARCHAR NOT NULL,  
5   duration INT  
6 );  
7  
8 CREATE VIEW comedies AS  
9 SELECT id, name  
10 FROM films  
11 WHERE kind \= 'Comedy' \[...\];  
12 \-- команда  
13 INSERT INTO comedies(id, name) VALUES (7, 'New Comedy Film');

1. except  
2. with check option  
3. limit  
4. union  
5. distinct